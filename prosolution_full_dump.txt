================================================================================
PROSOLUTION IA ‚Äî FULL PROJECT DUMP
================================================================================
Base path: C:\Users\eduar\Desktop\Api-prosolution-main


--------------------------------------------------------------------------------
FILE: .env.example
--------------------------------------------------------------------------------

# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution


--------------------------------------------------------------------------------
FILE: app\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\ai\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\ai\admin\policies.py
--------------------------------------------------------------------------------
FORBIDDEN_MARKETING_TOPICS = [
    "politica", "religiao", "ideologia", "lgbt",
    "orientacao sexual", "identidade de genero",
    "violencia", "odio", "seguranca publica",
    "armas", "saude sensivel"
]

def is_forbidden_topic(text: str) -> bool:
    text = text.lower()
    return any(topic in text for topic in FORBIDDEN_MARKETING_TOPICS)


--------------------------------------------------------------------------------
FILE: app\ai\admin\prompts.py
--------------------------------------------------------------------------------
SYSTEM_ADMIN_PROMPT = '''
Voc√™ √© a IA ADMINISTRADORA GERAL (AI GOVERNANCE ADMIN).

Voc√™ N√ÉO executa c√≥digo.
Voc√™ N√ÉO altera arquivos.
Voc√™ N√ÉO faz deploy.

Seu papel:
- Avaliar seguran√ßa
- Avaliar c√≥digo
- Avaliar LGPD
- Avaliar riscos jur√≠dicos
- Avaliar bugs prov√°veis
- Avaliar depend√™ncias

No final gere UM PROMPT com:
üî¥ OBRIGAT√ìRIO
üü° NECESS√ÅRIO
üü¢ MELHORIAS OPCIONAIS
'''


--------------------------------------------------------------------------------
FILE: app\ai\admin\system_admin.py
--------------------------------------------------------------------------------
from app.ai.providers.openai import OpenAIProvider
from app.ai.providers.gemini import GeminiProvider
from app.ai.admin.prompts import SYSTEM_ADMIN_PROMPT

openai = OpenAIProvider()
gemini = GeminiProvider()

def evaluate_system(system_snapshot: dict) -> str:
    tech = openai.generate(f"Analise tecnicamente:\n{system_snapshot}")
    product = gemini.generate(f"Avalie produto e UX:\n{system_snapshot}")

    final = openai.generate(
        SYSTEM_ADMIN_PROMPT +
        "\nAN√ÅLISE T√âCNICA:\n" + tech +
        "\nAN√ÅLISE PRODUTO:\n" + product
    )
    return final


--------------------------------------------------------------------------------
FILE: app\ai\chatgpt_service.py
--------------------------------------------------------------------------------
import httpx
from app.config import OPENAI_API_KEY

OPENAI_URL = "https://api.openai.com/v1/chat/completions"

async def generate_with_chatgpt(prompt: str):
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "gpt-4o-mini",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.7
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(OPENAI_URL, headers=headers, json=payload)

    data = res.json()
    return data["choices"][0]["message"]["content"]

--------------------------------------------------------------------------------
FILE: app\ai\content_generator.py
--------------------------------------------------------------------------------
from app.ai.gemini_service import generate_with_gemini
from app.ai.chatgpt_service import generate_with_chatgpt

async def generate_content(niche: str, objective: str):
    prompt = f"""
Crie uma legenda para Instagram.
Nicho: {niche}
Objetivo: {objective}
Inclua hashtags.
"""

    try:
        return await generate_with_gemini(prompt)
    except:
        return await generate_with_chatgpt(prompt)

--------------------------------------------------------------------------------
FILE: app\ai\gemini_service.py
--------------------------------------------------------------------------------
import httpx
from fastapi import HTTPException
from app.config import GEMINI_API_KEY

GEMINI_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent"

async def generate_with_gemini(prompt: str):
    payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(
            GEMINI_URL,
            params={"key": GEMINI_API_KEY},
            json=payload
        )

    data = res.json()

    if res.status_code != 200:
        raise HTTPException(400, data)

    return data["candidates"][0]["content"]["parts"][0]["text"]

--------------------------------------------------------------------------------
FILE: app\ai\orchestrator.py
--------------------------------------------------------------------------------

from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)


--------------------------------------------------------------------------------
FILE: app\ai\providers\base.py
--------------------------------------------------------------------------------

from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass


--------------------------------------------------------------------------------
FILE: app\ai\providers\gemini.py
--------------------------------------------------------------------------------

import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text


--------------------------------------------------------------------------------
FILE: app\ai\providers\openai.py
--------------------------------------------------------------------------------

from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content


--------------------------------------------------------------------------------
FILE: app\ai\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.ai.orchestrator import generate_instagram_content
from app.ai.admin.system_admin import evaluate_system

router = APIRouter(prefix="/ai", tags=["AI"])

@router.post("/instagram-content")
def instagram_content(topic: str):
    return generate_instagram_content(topic)

@router.post("/admin-review")
def admin_review(system_snapshot: dict):
    return {"admin_prompt": evaluate_system(system_snapshot)}


--------------------------------------------------------------------------------
FILE: app\ai\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel

class GeminiInstagramSchema(BaseModel):
    niche: str
    objective: str
    language: str = "pt-BR"

--------------------------------------------------------------------------------
FILE: app\auth\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\auth\routes.py
--------------------------------------------------------------------------------

from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user


--------------------------------------------------------------------------------
FILE: app\auth\security.py
--------------------------------------------------------------------------------
from fastapi import Depends, HTTPException, status

async def get_current_user():
    # üîê Placeholder simples (n√£o quebra o sistema)
    return {"role": "admin"}


--------------------------------------------------------------------------------
FILE: app\auth.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models import User
from app.security import verify_password, create_token
from app.vpn_block import is_vpn

router = APIRouter()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.post("/login")
def login(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    ip = request.client.host
    if is_vpn(ip):
        return {"error": "VPN/Proxy bloqueado"}

    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.password):
        return {"error": "Credenciais inv√°lidas"}

    token = create_token({
        "sub": user.email,
        "admin": user.is_admin,
        "plan": user.plan
    })

    resp = RedirectResponse("/dashboard", 302)
    resp.set_cookie("token", token, httponly=True)
    return resp
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates")

@router.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})


--------------------------------------------------------------------------------
FILE: app\config.py
--------------------------------------------------------------------------------
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # === APP ===
    ENV: str = "development"

    # === DATABASE ===
    DATABASE_URL: str = "sqlite+aiosqlite:///./prosolution.db"
    DB_ECHO: bool = False
    DB_POOL_SIZE: int = 10

    # === AUTH / SECURITY ===
    SECRET_KEY: str = "CHANGE_ME"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24

    # === OPENAI ===
    OPENAI_API_KEY: str | None = None

    # === GEMINI ===
    GEMINI_API_KEY: str | None = None

    # === INSTAGRAM ===
    INSTAGRAM_ACCESS_TOKEN: str | None = None
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str | None = None
    INSTAGRAM_API_VERSION: str = "v19.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    # === MERCADO PAGO ===
    MERCADO_PAGO_ACCESS_TOKEN: str | None = None
    MERCADO_PAGO_WEBHOOK_SECRET: str | None = None

    # === Pydantic v2 config ===
    model_config = SettingsConfigDict(
        env_file=".env",
        extra="ignore",  # <<< ISSO EVITA ERROS DE VARI√ÅVEIS A MAIS
    )


settings = Settings()


--------------------------------------------------------------------------------
FILE: app\dashboard\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\dashboard\metrics.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.dashboard.repository import get_dashboard_metrics

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])

@router.get("/metrics")
async def metrics():
    return await get_dashboard_metrics()


--------------------------------------------------------------------------------
FILE: app\dashboard\repository.py
--------------------------------------------------------------------------------
from sqlalchemy import select, func
from app.database.session import AsyncSessionLocal
from app.database.models.dashboard import Post, Payment, AILog

async def get_dashboard_metrics():
    async with AsyncSessionLocal() as session:
        posts_total = await session.scalar(select(func.count(Post.id)))
        payments_total = await session.scalar(select(func.count(Payment.id)))
        revenue_total = await session.scalar(select(func.coalesce(func.sum(Payment.amount), 0)))
        last_post = await session.scalar(
            select(Post.caption).order_by(Post.created_at.desc())
        )
        last_ai_action = await session.scalar(
            select(AILog.action).order_by(AILog.created_at.desc())
        )

        return {
            "posts_total": posts_total or 0,
            "payments_total": payments_total or 0,
            "revenue_total": float(revenue_total or 0),
            "last_post": last_post,
            "last_ai_action": last_ai_action,
        }


--------------------------------------------------------------------------------
FILE: app\dashboard\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.templating import Jinja2Templates
from datetime import datetime
import requests

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])
templates = Jinja2Templates(directory="templates")

@router.get("/")
def dashboard(request: Request):
    ip = request.client.host

    try:
        geo = requests.get(f"https://ipapi.co/{ip}/json/").json()
    except:
        geo = {}

    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "ip": ip,
            "city": geo.get("city", "Unknown"),
            "country": geo.get("country_name", "Unknown"),
            "org": geo.get("org", "Unknown"),
            "datetime": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "vpn_status": "OFF"
        }
    )


--------------------------------------------------------------------------------
FILE: app\dashboard.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from jose import jwt
import os

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    token = request.cookies.get("token")
    if not token:
        return {"error": "N√£o autenticado"}

    data = jwt.decode(token, os.getenv("SECRET_KEY"), algorithms=["HS256"])
    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "user": data}
    )



--------------------------------------------------------------------------------
FILE: app\database\__init__.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "sqlite:///./prosolution.db"
)

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
    if DATABASE_URL.startswith("sqlite")
    else {}
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\app\database\models\user.py
--------------------------------------------------------------------------------
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from app.database.base import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

--------------------------------------------------------------------------------
FILE: app\database\automation_repository.py
--------------------------------------------------------------------------------
import sqlite3

DB_PATH = "app/database/database.db"


def init_automation_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS automation_config (
            id INTEGER PRIMARY KEY,
            enabled BOOLEAN,
            times TEXT
        )
    """)

    cursor.execute("""
        INSERT OR IGNORE INTO automation_config (id, enabled, times)
        VALUES (1, 0, '')
    """)

    conn.commit()
    conn.close()


def save_config(enabled, times):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE automation_config
        SET enabled = ?, times = ?
        WHERE id = 1
    """, (enabled, ",".join(times)))

    conn.commit()
    conn.close()


--------------------------------------------------------------------------------
FILE: app\database\base.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.models import Base

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


--------------------------------------------------------------------------------
FILE: app\database\client_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.hash import bcrypt

def init_clients_table():
    conn = get_connection()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            email TEXT UNIQUE,
            password_hash TEXT,
            plan TEXT
        )
    """)

    # üëë cria admin se n√£o existir
    cursor.execute(
        "SELECT id FROM clients WHERE email = ?",
        ("admin@admin.com",)
    )

    if not cursor.fetchone():
        cursor.execute("""
            INSERT INTO clients (name, email, password_hash, plan)
            VALUES (?, ?, ?, ?)
        """, (
            "Administrador",
            "admin@admin.com",
            bcrypt.hash("123456"),
            "admin"
        ))

    conn.commit()
    conn.close()

from app.database.db import get_session
from app.database.models import Client
from app.auth.security import hash_password


def ensure_admin_exists():
    session = get_session()

    try:
        admin = session.query(Client).filter(
            Client.email == "admin@admin.com"
        ).first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=hash_password("123456"),
                plan="admin",
                active=True
            )
            session.add(admin)
            session.commit()
            print("[BOOTSTRAP] Admin criado com sucesso")
        else:
            print("[BOOTSTRAP] Admin j√° existe")

    finally:
        session.close()

def create_admin_if_not_exists():
    db = SessionLocal()
    try:
        admin = db.query(Client).filter(Client.email == "admin@admin.com").first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=get_password_hash("123456"),
                plan="admin"
            )
            db.add(admin)
            db.commit()
            print("‚úÖ Admin criado com sucesso")
        else:
            print("‚ÑπÔ∏è Admin j√° existe")

    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\db.py
--------------------------------------------------------------------------------
import sqlite3

DB_NAME = "database.db"

def get_connection():
    conn = sqlite3.connect(DB_NAME, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


--------------------------------------------------------------------------------
FILE: app\database\migrations\env.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.base import Base
target_metadata = Base.metadata

def run_migrations_online():
    from alembic import context
    connectable = engine.sync_engine
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

--------------------------------------------------------------------------------
FILE: app\database\models\__init__.py
--------------------------------------------------------------------------------
 from app.database.models.base import Base

# Importar models para o SQLAlchemy registrar
from app.database.models.user import User
from app.database.models.post import Post


--------------------------------------------------------------------------------
FILE: app\database\models\base.py
--------------------------------------------------------------------------------
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass


--------------------------------------------------------------------------------
FILE: app\database\models\dashboard.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, DateTime, Numeric
from sqlalchemy.sql import func
from app.database.base import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True)
    instagram_id = Column(String, unique=True)
    caption = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class Payment(Base):
    __tablename__ = "payments"

    id = Column(Integer, primary_key=True)
    mp_payment_id = Column(String, unique=True)
    status = Column(String)
    amount = Column(Numeric)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class AILog(Base):
    __tablename__ = "ai_logs"

    id = Column(Integer, primary_key=True)
    action = Column(String)
    provider = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


--------------------------------------------------------------------------------
FILE: app\database\models\post.py
--------------------------------------------------------------------------------
from sqlalchemy import String, Text
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class Post(Base):
    __tablename__ = "posts"

    id: Mapped[int] = mapped_column(primary_key=True)
    content: Mapped[str] = mapped_column(Text)


--------------------------------------------------------------------------------
FILE: app\database\models\user.py
--------------------------------------------------------------------------------
from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password_hash: Mapped[str]


--------------------------------------------------------------------------------
FILE: app\database\post_repository.py
--------------------------------------------------------------------------------
import sqlite3
from datetime import datetime

DB_PATH = "app/database/database.db"


def init_posts_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            client_id INTEGER,
            content TEXT,
            source TEXT,
            mode TEXT,
            created_at TEXT
        )
    """)

    conn.commit()
    conn.close()


def save_post(client_id, content, source, mode):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO posts (client_id, content, source, mode, created_at)
        VALUES (?, ?, ?, ?, ?)
    """, (client_id, content, source, mode, datetime.now().isoformat()))

    conn.commit()
    conn.close()


def list_posts(client_id, limit=50):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT content, source, mode, created_at
        FROM posts
        WHERE client_id = ?
        ORDER BY id DESC
        LIMIT ?
    """, (client_id, limit))

    rows = cursor.fetchall()
    conn.close()
    return rows


--------------------------------------------------------------------------------
FILE: app\database\repositories\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\database\repositories\post_repository.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from app.database.models.post import InstagramPost

async def save_post(
    db: AsyncSession,
    instagram_id: str,
    image_url: str,
    caption: str
):
    post = InstagramPost(
        instagram_id=instagram_id,
        image_url=image_url,
        caption=caption
    )
    db.add(post)
    await db.commit()
    await db.refresh(post)
    return post

--------------------------------------------------------------------------------
FILE: app\database\repositories\user_repo.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from app.database.models.user import User

class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, user_data: dict) -> User:
        user = User(**user_data)
        self.session.add(user)
        await self.session.commit()
        await self.session.refresh(user)
        return user

    async def get_by_id(self, user_id: str):
        result = await self.session.execute(select(User).filter_by(id=user_id))
        return result.scalars().first()

    async def get_by_email(self, email: str):
        result = await self.session.execute(select(User).filter_by(email=email))
        return result.scalars().first()

    async def list_all(self):
        result = await self.session.execute(select(User))
        return result.scalars().all()

    async def update(self, user_id: str, data: dict):
        await self.session.execute(update(User).where(User.id == user_id).values(**data))
        await self.session.commit()
        return await self.get_by_id(user_id)

    async def delete(self, user_id: str):
        await self.session.execute(delete(User).where(User.id == user_id))
        await self.session.commit()

--------------------------------------------------------------------------------
FILE: app\database\seed_admin.py
--------------------------------------------------------------------------------
from app.database.user_repository import create_table, create_user

create_table()
create_user("admin@prosolution.com", "admin123")
print("‚úÖ Admin criado")


--------------------------------------------------------------------------------
FILE: app\database\session.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session


--------------------------------------------------------------------------------
FILE: app\database\user_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.context import CryptContext

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_table():
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL
        )
    """)
    conn.commit()
    conn.close()

def create_user(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (email, password) VALUES (?, ?)",
        (email, pwd.hash(password))
    )
    conn.commit()
    conn.close()

def authenticate(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
    user = cursor.fetchone()
    conn.close()

    if user and pwd.verify(password, user["password"]):
        return dict(user)
    return None


--------------------------------------------------------------------------------
FILE: app\database.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

Base = declarative_base()


--------------------------------------------------------------------------------
FILE: app\instagram\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\instagram\client.py
--------------------------------------------------------------------------------
import requests
from app.config import settings

BASE_URL = f"{settings.INSTAGRAM_BASE_URL}/{settings.INSTAGRAM_API_VERSION}"

def create_media(image_url: str, caption: str) -> str:
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media"

    payload = {
        "image_url": image_url,
        "caption": caption,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()["id"]

def publish_media(creation_id: str):
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media_publish"

    payload = {
        "creation_id": creation_id,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()


--------------------------------------------------------------------------------
FILE: app\instagram\post.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from app.instagram.service import publish_image
from app.instagram.schemas import InstagramPostRequest

router = APIRouter()

@router.post("/post")
def post_instagram(data: InstagramPostRequest):
    try:
        return publish_image(data.image_url, data.caption)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


--------------------------------------------------------------------------------
FILE: app\instagram\router.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.instagram.post import router as post_router

router = APIRouter(prefix="/instagram", tags=["Instagram"])
router.include_router(post_router)


--------------------------------------------------------------------------------
FILE: app\instagram\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, HttpUrl, Field

class InstagramPostSchema(BaseModel):
    image_url: HttpUrl = Field(..., example="https://example.com/image.jpg")
    caption: str = Field(..., min_length=1, max_length=2200)

    class Config:
        extra = "forbid"  # evita campos inv√°lidos

from pydantic import BaseModel, HttpUrl


class InstagramPostRequest(BaseModel):
    image_url: HttpUrl
    caption: str

--------------------------------------------------------------------------------
FILE: app\instagram\service.py
--------------------------------------------------------------------------------
from app.instagram.client import create_media, publish_media
from app.config import settings

def publish_image(image_url: str, caption: str):
    if not settings.INSTAGRAM_ACCESS_TOKEN:
        raise RuntimeError("Instagram n√£o configurado")

    creation_id = create_media(image_url, caption)
    return publish_media(creation_id)


--------------------------------------------------------------------------------
FILE: app\instagram\test_token.py
--------------------------------------------------------------------------------
import requests
from app.config import INSTAGRAM_ACCESS_TOKEN

url = "https://graph.facebook.com/v19.0/me"
params = {
    "access_token": INSTAGRAM_ACCESS_TOKEN
}

r = requests.get(url, params=params)
print(r.json())

--------------------------------------------------------------------------------
FILE: app\main.py
--------------------------------------------------------------------------------
from fastapi import FastAPI, Request, Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# Routers
from app.auth.routes import router as auth_router
from app.dashboard.routes import router as dashboard_router
from app.instagram.router import router as instagram_router
from app.ai.routes import router as ai_router
from app.payments.routes import router as payments_router

# Database
from app.database.base import init_db
from app.database.session import get_db
from app.database.repositories.user_repo import UserRepository

app = FastAPI(title="Prosolution API")

# === STARTUP ===
@app.on_event("startup")
async def startup():
    await init_db()

# === STATIC / TEMPLATES ===
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# === HOME ===
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

# === ROUTERS ===
app.include_router(auth_router, prefix="/auth")
app.include_router(dashboard_router)
app.include_router(instagram_router)
app.include_router(ai_router)
app.include_router(payments_router)

# === API TEST ===
@app.get("/api")
async def api_root():
    return {"status": "üöÄ Prosolution API online"}

# === USERS (TESTE) ===
@app.get("/api/users")
async def list_users(db=Depends(get_db)):
    return await UserRepository(db).list_all()


--------------------------------------------------------------------------------
FILE: app\models.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, Boolean
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    password = Column(String)
    is_admin = Column(Boolean, default=False)
    plan = Column(String, default="free")


--------------------------------------------------------------------------------
FILE: app\payments\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\payments\mercadopago_client.py
--------------------------------------------------------------------------------
import httpx
from app.config import settings


class MercadoPagoClient:
    def __init__(self):
        self.base_url = "https://api.mercadopago.com"
        self.headers = {
            "Authorization": f"Bearer {settings.MERCADO_PAGO_ACCESS_TOKEN}",
            "Content-Type": "application/json",
        }

    async def create_payment(self, payload: dict):
        async with httpx.AsyncClient(timeout=20) as client:
            response = await client.post(
                f"{self.base_url}/v1/payments",
                headers=self.headers,
                json=payload,
            )

        return response

--------------------------------------------------------------------------------
FILE: app\payments\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.payments.schemas import PixPaymentSchema
from app.payments.service import create_pix_payment

router = APIRouter(prefix="/payments", tags=["Payments"])


@router.post("/pix")
async def create_pix_payment_route(data: PixPaymentSchema):
    return await create_pix_payment(
        amount=data.amount,
        description=data.description,
        email=data.email,
    )

--------------------------------------------------------------------------------
FILE: app\payments\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, Field
from typing import Optional

# EmailStr protegido (n√£o quebra se faltar depend√™ncia)
try:
    from pydantic import EmailStr
except ImportError:
    EmailStr = str


class PixPaymentSchema(BaseModel):
    name: str = Field(..., min_length=2)
    email: EmailStr
    amount: float = Field(..., gt=0)
    description: Optional[str] = None


--------------------------------------------------------------------------------
FILE: app\payments\service.py
--------------------------------------------------------------------------------
from fastapi import HTTPException
from app.payments.mercadopago_client import MercadoPagoClient

client = MercadoPagoClient()


async def create_pix_payment(amount: float, description: str, email: str):
    payload = {
        "transaction_amount": amount,
        "description": description,
        "payment_method_id": "pix",
        "payer": {
            "email": email
        }
    }

    response = await client.create_payment(payload)
    data = response.json()

    if response.status_code not in (200, 201):
        raise HTTPException(
            status_code=400,
            detail={
                "stage": "mercado_pago_payment",
                "error": data
            }
        )

    transaction_data = data.get("point_of_interaction", {}).get("transaction_data", {})

    return {
        "payment_id": data.get("id"),
        "status": data.get("status"),
        "qr_code": transaction_data.get("qr_code"),
        "qr_code_base64": transaction_data.get("qr_code_base64"),
    }

--------------------------------------------------------------------------------
FILE: app\scheduler\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\scheduler\post_runner.py
--------------------------------------------------------------------------------
from app.ai.content_generator import generate_post
from app.database.post_repository import save_post


def run_post(client_id=None, manual=False):
    content = generate_post()
    source = "fallback" if "fallback" in content.lower() else "openai"
    mode = "manual" if manual else "automatic"

    if client_id:
        save_post(client_id, content, source, mode)

    print("[POST]", content)


--------------------------------------------------------------------------------
FILE: app\scheduler\scheduler.py
--------------------------------------------------------------------------------

from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)


--------------------------------------------------------------------------------
FILE: app\security.py
--------------------------------------------------------------------------------
import os
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password):
    return pwd.hash(password)

def verify_password(password, hashed):
    return pwd.verify(password, hashed)

def create_token(data: dict):
    data["exp"] = datetime.utcnow() + timedelta(hours=2)
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)


--------------------------------------------------------------------------------
FILE: app\utils\security.py
--------------------------------------------------------------------------------
import requests

API_KEY = "SUA_CHAVE_IPQUALITYSCORE"

def is_vpn(ip: str) -> bool:
    url = f"https://ipqualityscore.com/api/json/ip/{API_KEY}/{ip}"
    data = requests.get(url, timeout=5).json()

    return any([
        data.get("vpn"),
        data.get("proxy"),
        data.get("tor"),
        data.get("hosting")
    ])


--------------------------------------------------------------------------------
FILE: app\vpn_block.py
--------------------------------------------------------------------------------
import requests

def is_vpn(ip: str):
    try:
        r = requests.get(f"https://ip-api.com/json/{ip}?fields=proxy,hosting")
        data = r.json()
        return data.get("proxy") or data.get("hosting")
    except:
        return False


--------------------------------------------------------------------------------
FILE: apply_prosolution_fixes.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

ROOT = Path.cwd()

def write(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"‚úî atualizado: {path}")

# ======================================================
# 1Ô∏è‚É£ .env.example (SEGURAN√áA)
# ======================================================
write(ROOT / ".env.example", """
# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution
""")

# ======================================================
# 2Ô∏è‚É£ BANCO DE DADOS ‚Äî UNIFICADO (ASYNC POSTGRES)
# ======================================================
write(ROOT / "app/database/session.py", """
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)
AsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False)
""")

write(ROOT / "app/database/base.py", """
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass
""")

# ======================================================
# 3Ô∏è‚É£ AUTH √öNICA (REMOVE AUTH FAKE)
# ======================================================
write(ROOT / "app/auth/routes.py", """
from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user
""")

# ======================================================
# 4Ô∏è‚É£ IA ‚Äî PADRONIZA√á√ÉO PROVIDERS
# ======================================================
write(ROOT / "app/ai/providers/base.py", """
from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass
""")

write(ROOT / "app/ai/providers/gemini.py", """
import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text
""")

write(ROOT / "app/ai/providers/openai.py", """
from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content
""")

# ======================================================
# 5Ô∏è‚É£ ORQUESTRADOR IA (√öNICO)
# ======================================================
write(ROOT / "app/ai/orchestrator.py", """
from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)
""")

# ======================================================
# 6Ô∏è‚É£ SCHEDULER CORRIGIDO
# ======================================================
write(ROOT / "app/scheduler/scheduler.py", """
from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)
""")

# ======================================================
# 7Ô∏è‚É£ CONFIG CENTRALIZADA
# ======================================================
write(ROOT / "app/config.py", """
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    INSTAGRAM_ACCESS_TOKEN: str = ""
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str = ""
    INSTAGRAM_API_VERSION: str = "v24.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    GEMINI_API_KEY: str = ""
    OPENAI_API_KEY: str = ""

    DATABASE_URL: str = ""

    class Config:
        env_file = ".env"

settings = Settings()
""")

print("\\n‚úÖ TODAS AS CORRE√á√ïES FORAM APLICADAS COM SUCESSO")


--------------------------------------------------------------------------------
FILE: apply_prosolution_runtime_fixes.py
--------------------------------------------------------------------------------
import subprocess
import sys
from pathlib import Path

BASE = Path(__file__).parent
REQ = BASE / "requirements.txt"

REQUIRED_PACKAGES = [
    "email-validator",
    "pydantic[email]",
]

def run(cmd):
    print(f"‚ñ∂ {cmd}")
    subprocess.check_call(cmd, shell=True)

def ensure_requirements():
    content = REQ.read_text(encoding="utf-8")

    updated = False
    for pkg in REQUIRED_PACKAGES:
        if pkg.split("[")[0] not in content:
            content += f"\n{pkg}"
            updated = True

    if updated:
        REQ.write_text(content, encoding="utf-8")
        print("‚úî requirements.txt atualizado")
    else:
        print("‚Ñπ requirements.txt j√° estava correto")

def install():
    run(f"{sys.executable} -m pip install --upgrade pip")
    run(f"{sys.executable} -m pip install -r requirements.txt")

def patch_email_schema():
    schemas = BASE / "app" / "payments" / "schemas.py"
    if not schemas.exists():
        return

    txt = schemas.read_text(encoding="utf-8")

    if "EmailStr" in txt:
        txt = txt.replace(
            "from pydantic import BaseModel, EmailStr",
            "from pydantic import BaseModel\nfrom typing import Optional\n\n# EmailStr protegido\ntry:\n    from pydantic import EmailStr\nexcept ImportError:\n    EmailStr = str"
        )
        schemas.write_text(txt, encoding="utf-8")
        print("‚úî Schema de pagamento protegido contra crash")

def main():
    print("\nüöÄ APLICANDO FIXES DEFINITIVOS (PROSOLUTION)\n")
    ensure_requirements()
    install()
    patch_email_schema()
    print("\n‚úÖ SISTEMA PRONTO PARA SUBIR")

if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: dump_prosolution.py
--------------------------------------------------------------------------------
from pathlib import Path

BASE_DIR = Path(__file__).parent
OUTPUT_FILE = BASE_DIR / "prosolution_full_dump.txt"

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    ".idea",
    ".vscode",
    "node_modules",
}

INCLUDE_EXTENSIONS = {
    ".py",
    ".txt",
    ".md",
    ".html",
    ".css",
    ".js",
    ".env",
    ".example",
}


def should_include(path: Path) -> bool:
    if any(part in EXCLUDE_DIRS for part in path.parts):
        return False
    if path.is_file() and path.suffix.lower() in INCLUDE_EXTENSIONS:
        return True
    return False


def main():
    lines = []
    lines.append("=" * 80)
    lines.append("PROSOLUTION IA ‚Äî FULL PROJECT DUMP")
    lines.append("=" * 80)
    lines.append(f"Base path: {BASE_DIR}")
    lines.append("")

    for file_path in sorted(BASE_DIR.rglob("*")):
        if should_include(file_path):
            rel = file_path.relative_to(BASE_DIR)
            lines.append("\n" + "-" * 80)
            lines.append(f"FILE: {rel}")
            lines.append("-" * 80)
            try:
                content = file_path.read_text(encoding="utf-8", errors="ignore")
                lines.append(content)
            except Exception as e:
                lines.append(f"[ERROR READING FILE]: {e}")

    OUTPUT_FILE.write_text("\n".join(lines), encoding="utf-8")
    print(f"‚úÖ Dump gerado com sucesso: {OUTPUT_FILE}")


if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: prosolution_full_dump.txt
--------------------------------------------------------------------------------
================================================================================
PROSOLUTION IA ‚Äî FULL PROJECT DUMP
================================================================================
Base path: C:\Users\eduar\Desktop\Api-prosolution-main


--------------------------------------------------------------------------------
FILE: .env.example
--------------------------------------------------------------------------------

# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution


--------------------------------------------------------------------------------
FILE: app\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\ai\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\ai\admin\policies.py
--------------------------------------------------------------------------------
FORBIDDEN_MARKETING_TOPICS = [
    "politica", "religiao", "ideologia", "lgbt",
    "orientacao sexual", "identidade de genero",
    "violencia", "odio", "seguranca publica",
    "armas", "saude sensivel"
]

def is_forbidden_topic(text: str) -> bool:
    text = text.lower()
    return any(topic in text for topic in FORBIDDEN_MARKETING_TOPICS)


--------------------------------------------------------------------------------
FILE: app\ai\admin\prompts.py
--------------------------------------------------------------------------------
SYSTEM_ADMIN_PROMPT = '''
Voc√™ √© a IA ADMINISTRADORA GERAL (AI GOVERNANCE ADMIN).

Voc√™ N√ÉO executa c√≥digo.
Voc√™ N√ÉO altera arquivos.
Voc√™ N√ÉO faz deploy.

Seu papel:
- Avaliar seguran√ßa
- Avaliar c√≥digo
- Avaliar LGPD
- Avaliar riscos jur√≠dicos
- Avaliar bugs prov√°veis
- Avaliar depend√™ncias

No final gere UM PROMPT com:
üî¥ OBRIGAT√ìRIO
üü° NECESS√ÅRIO
üü¢ MELHORIAS OPCIONAIS
'''


--------------------------------------------------------------------------------
FILE: app\ai\admin\system_admin.py
--------------------------------------------------------------------------------
from app.ai.providers.openai import OpenAIProvider
from app.ai.providers.gemini import GeminiProvider
from app.ai.admin.prompts import SYSTEM_ADMIN_PROMPT

openai = OpenAIProvider()
gemini = GeminiProvider()

def evaluate_system(system_snapshot: dict) -> str:
    tech = openai.generate(f"Analise tecnicamente:\n{system_snapshot}")
    product = gemini.generate(f"Avalie produto e UX:\n{system_snapshot}")

    final = openai.generate(
        SYSTEM_ADMIN_PROMPT +
        "\nAN√ÅLISE T√âCNICA:\n" + tech +
        "\nAN√ÅLISE PRODUTO:\n" + product
    )
    return final


--------------------------------------------------------------------------------
FILE: app\ai\chatgpt_service.py
--------------------------------------------------------------------------------
import httpx
from app.config import OPENAI_API_KEY

OPENAI_URL = "https://api.openai.com/v1/chat/completions"

async def generate_with_chatgpt(prompt: str):
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "gpt-4o-mini",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.7
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(OPENAI_URL, headers=headers, json=payload)

    data = res.json()
    return data["choices"][0]["message"]["content"]

--------------------------------------------------------------------------------
FILE: app\ai\content_generator.py
--------------------------------------------------------------------------------
from app.ai.gemini_service import generate_with_gemini
from app.ai.chatgpt_service import generate_with_chatgpt

async def generate_content(niche: str, objective: str):
    prompt = f"""
Crie uma legenda para Instagram.
Nicho: {niche}
Objetivo: {objective}
Inclua hashtags.
"""

    try:
        return await generate_with_gemini(prompt)
    except:
        return await generate_with_chatgpt(prompt)

--------------------------------------------------------------------------------
FILE: app\ai\gemini_service.py
--------------------------------------------------------------------------------
import httpx
from fastapi import HTTPException
from app.config import GEMINI_API_KEY

GEMINI_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent"

async def generate_with_gemini(prompt: str):
    payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(
            GEMINI_URL,
            params={"key": GEMINI_API_KEY},
            json=payload
        )

    data = res.json()

    if res.status_code != 200:
        raise HTTPException(400, data)

    return data["candidates"][0]["content"]["parts"][0]["text"]

--------------------------------------------------------------------------------
FILE: app\ai\orchestrator.py
--------------------------------------------------------------------------------

from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)


--------------------------------------------------------------------------------
FILE: app\ai\providers\base.py
--------------------------------------------------------------------------------

from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass


--------------------------------------------------------------------------------
FILE: app\ai\providers\gemini.py
--------------------------------------------------------------------------------

import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text


--------------------------------------------------------------------------------
FILE: app\ai\providers\openai.py
--------------------------------------------------------------------------------

from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content


--------------------------------------------------------------------------------
FILE: app\ai\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.ai.orchestrator import generate_instagram_content
from app.ai.admin.system_admin import evaluate_system

router = APIRouter(prefix="/ai", tags=["AI"])

@router.post("/instagram-content")
def instagram_content(topic: str):
    return generate_instagram_content(topic)

@router.post("/admin-review")
def admin_review(system_snapshot: dict):
    return {"admin_prompt": evaluate_system(system_snapshot)}


--------------------------------------------------------------------------------
FILE: app\ai\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel

class GeminiInstagramSchema(BaseModel):
    niche: str
    objective: str
    language: str = "pt-BR"

--------------------------------------------------------------------------------
FILE: app\auth\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\auth\routes.py
--------------------------------------------------------------------------------

from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user


--------------------------------------------------------------------------------
FILE: app\auth\security.py
--------------------------------------------------------------------------------
from fastapi import Depends, HTTPException, status

async def get_current_user():
    # üîê Placeholder simples (n√£o quebra o sistema)
    return {"role": "admin"}


--------------------------------------------------------------------------------
FILE: app\auth.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models import User
from app.security import verify_password, create_token
from app.vpn_block import is_vpn

router = APIRouter()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.post("/login")
def login(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    ip = request.client.host
    if is_vpn(ip):
        return {"error": "VPN/Proxy bloqueado"}

    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.password):
        return {"error": "Credenciais inv√°lidas"}

    token = create_token({
        "sub": user.email,
        "admin": user.is_admin,
        "plan": user.plan
    })

    resp = RedirectResponse("/dashboard", 302)
    resp.set_cookie("token", token, httponly=True)
    return resp
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates")

@router.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})


--------------------------------------------------------------------------------
FILE: app\config.py
--------------------------------------------------------------------------------
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # === APP ===
    ENV: str = "development"

    # === DATABASE ===
    DATABASE_URL: str = "sqlite+aiosqlite:///./prosolution.db"
    DB_ECHO: bool = False
    DB_POOL_SIZE: int = 10

    # === AUTH / SECURITY ===
    SECRET_KEY: str = "CHANGE_ME"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24

    # === OPENAI ===
    OPENAI_API_KEY: str | None = None

    # === GEMINI ===
    GEMINI_API_KEY: str | None = None

    # === INSTAGRAM ===
    INSTAGRAM_ACCESS_TOKEN: str | None = None
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str | None = None
    INSTAGRAM_API_VERSION: str = "v19.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    # === MERCADO PAGO ===
    MERCADO_PAGO_ACCESS_TOKEN: str | None = None
    MERCADO_PAGO_WEBHOOK_SECRET: str | None = None

    # === Pydantic v2 config ===
    model_config = SettingsConfigDict(
        env_file=".env",
        extra="ignore",  # <<< ISSO EVITA ERROS DE VARI√ÅVEIS A MAIS
    )


settings = Settings()


--------------------------------------------------------------------------------
FILE: app\dashboard\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\dashboard\metrics.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.dashboard.repository import get_dashboard_metrics

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])

@router.get("/metrics")
async def metrics():
    return await get_dashboard_metrics()


--------------------------------------------------------------------------------
FILE: app\dashboard\repository.py
--------------------------------------------------------------------------------
from sqlalchemy import select, func
from app.database.session import AsyncSessionLocal
from app.database.models.dashboard import Post, Payment, AILog

async def get_dashboard_metrics():
    async with AsyncSessionLocal() as session:
        posts_total = await session.scalar(select(func.count(Post.id)))
        payments_total = await session.scalar(select(func.count(Payment.id)))
        revenue_total = await session.scalar(select(func.coalesce(func.sum(Payment.amount), 0)))
        last_post = await session.scalar(
            select(Post.caption).order_by(Post.created_at.desc())
        )
        last_ai_action = await session.scalar(
            select(AILog.action).order_by(AILog.created_at.desc())
        )

        return {
            "posts_total": posts_total or 0,
            "payments_total": payments_total or 0,
            "revenue_total": float(revenue_total or 0),
            "last_post": last_post,
            "last_ai_action": last_ai_action,
        }


--------------------------------------------------------------------------------
FILE: app\dashboard\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.templating import Jinja2Templates
from datetime import datetime
import requests

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])
templates = Jinja2Templates(directory="templates")

@router.get("/")
def dashboard(request: Request):
    ip = request.client.host

    try:
        geo = requests.get(f"https://ipapi.co/{ip}/json/").json()
    except:
        geo = {}

    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "ip": ip,
            "city": geo.get("city", "Unknown"),
            "country": geo.get("country_name", "Unknown"),
            "org": geo.get("org", "Unknown"),
            "datetime": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "vpn_status": "OFF"
        }
    )


--------------------------------------------------------------------------------
FILE: app\dashboard.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from jose import jwt
import os

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    token = request.cookies.get("token")
    if not token:
        return {"error": "N√£o autenticado"}

    data = jwt.decode(token, os.getenv("SECRET_KEY"), algorithms=["HS256"])
    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "user": data}
    )



--------------------------------------------------------------------------------
FILE: app\database\__init__.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "sqlite:///./prosolution.db"
)

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
    if DATABASE_URL.startswith("sqlite")
    else {}
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\app\database\models\user.py
--------------------------------------------------------------------------------
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from app.database.base import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

--------------------------------------------------------------------------------
FILE: app\database\automation_repository.py
--------------------------------------------------------------------------------
import sqlite3

DB_PATH = "app/database/database.db"


def init_automation_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS automation_config (
            id INTEGER PRIMARY KEY,
            enabled BOOLEAN,
            times TEXT
        )
    """)

    cursor.execute("""
        INSERT OR IGNORE INTO automation_config (id, enabled, times)
        VALUES (1, 0, '')
    """)

    conn.commit()
    conn.close()


def save_config(enabled, times):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE automation_config
        SET enabled = ?, times = ?
        WHERE id = 1
    """, (enabled, ",".join(times)))

    conn.commit()
    conn.close()


--------------------------------------------------------------------------------
FILE: app\database\base.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.models import Base

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


--------------------------------------------------------------------------------
FILE: app\database\client_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.hash import bcrypt

def init_clients_table():
    conn = get_connection()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            email TEXT UNIQUE,
            password_hash TEXT,
            plan TEXT
        )
    """)

    # üëë cria admin se n√£o existir
    cursor.execute(
        "SELECT id FROM clients WHERE email = ?",
        ("admin@admin.com",)
    )

    if not cursor.fetchone():
        cursor.execute("""
            INSERT INTO clients (name, email, password_hash, plan)
            VALUES (?, ?, ?, ?)
        """, (
            "Administrador",
            "admin@admin.com",
            bcrypt.hash("123456"),
            "admin"
        ))

    conn.commit()
    conn.close()

from app.database.db import get_session
from app.database.models import Client
from app.auth.security import hash_password


def ensure_admin_exists():
    session = get_session()

    try:
        admin = session.query(Client).filter(
            Client.email == "admin@admin.com"
        ).first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=hash_password("123456"),
                plan="admin",
                active=True
            )
            session.add(admin)
            session.commit()
            print("[BOOTSTRAP] Admin criado com sucesso")
        else:
            print("[BOOTSTRAP] Admin j√° existe")

    finally:
        session.close()

def create_admin_if_not_exists():
    db = SessionLocal()
    try:
        admin = db.query(Client).filter(Client.email == "admin@admin.com").first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=get_password_hash("123456"),
                plan="admin"
            )
            db.add(admin)
            db.commit()
            print("‚úÖ Admin criado com sucesso")
        else:
            print("‚ÑπÔ∏è Admin j√° existe")

    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\db.py
--------------------------------------------------------------------------------
import sqlite3

DB_NAME = "database.db"

def get_connection():
    conn = sqlite3.connect(DB_NAME, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


--------------------------------------------------------------------------------
FILE: app\database\migrations\env.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.base import Base
target_metadata = Base.metadata

def run_migrations_online():
    from alembic import context
    connectable = engine.sync_engine
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

--------------------------------------------------------------------------------
FILE: app\database\models\__init__.py
--------------------------------------------------------------------------------
 from app.database.models.base import Base

# Importar models para o SQLAlchemy registrar
from app.database.models.user import User
from app.database.models.post import Post


--------------------------------------------------------------------------------
FILE: app\database\models\base.py
--------------------------------------------------------------------------------
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass


--------------------------------------------------------------------------------
FILE: app\database\models\dashboard.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, DateTime, Numeric
from sqlalchemy.sql import func
from app.database.base import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True)
    instagram_id = Column(String, unique=True)
    caption = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class Payment(Base):
    __tablename__ = "payments"

    id = Column(Integer, primary_key=True)
    mp_payment_id = Column(String, unique=True)
    status = Column(String)
    amount = Column(Numeric)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class AILog(Base):
    __tablename__ = "ai_logs"

    id = Column(Integer, primary_key=True)
    action = Column(String)
    provider = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


--------------------------------------------------------------------------------
FILE: app\database\models\post.py
--------------------------------------------------------------------------------
from sqlalchemy import String, Text
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class Post(Base):
    __tablename__ = "posts"

    id: Mapped[int] = mapped_column(primary_key=True)
    content: Mapped[str] = mapped_column(Text)


--------------------------------------------------------------------------------
FILE: app\database\models\user.py
--------------------------------------------------------------------------------
from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password_hash: Mapped[str]


--------------------------------------------------------------------------------
FILE: app\database\post_repository.py
--------------------------------------------------------------------------------
import sqlite3
from datetime import datetime

DB_PATH = "app/database/database.db"


def init_posts_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            client_id INTEGER,
            content TEXT,
            source TEXT,
            mode TEXT,
            created_at TEXT
        )
    """)

    conn.commit()
    conn.close()


def save_post(client_id, content, source, mode):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO posts (client_id, content, source, mode, created_at)
        VALUES (?, ?, ?, ?, ?)
    """, (client_id, content, source, mode, datetime.now().isoformat()))

    conn.commit()
    conn.close()


def list_posts(client_id, limit=50):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT content, source, mode, created_at
        FROM posts
        WHERE client_id = ?
        ORDER BY id DESC
        LIMIT ?
    """, (client_id, limit))

    rows = cursor.fetchall()
    conn.close()
    return rows


--------------------------------------------------------------------------------
FILE: app\database\repositories\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\database\repositories\post_repository.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from app.database.models.post import InstagramPost

async def save_post(
    db: AsyncSession,
    instagram_id: str,
    image_url: str,
    caption: str
):
    post = InstagramPost(
        instagram_id=instagram_id,
        image_url=image_url,
        caption=caption
    )
    db.add(post)
    await db.commit()
    await db.refresh(post)
    return post

--------------------------------------------------------------------------------
FILE: app\database\repositories\user_repo.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from app.database.models.user import User

class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, user_data: dict) -> User:
        user = User(**user_data)
        self.session.add(user)
        await self.session.commit()
        await self.session.refresh(user)
        return user

    async def get_by_id(self, user_id: str):
        result = await self.session.execute(select(User).filter_by(id=user_id))
        return result.scalars().first()

    async def get_by_email(self, email: str):
        result = await self.session.execute(select(User).filter_by(email=email))
        return result.scalars().first()

    async def list_all(self):
        result = await self.session.execute(select(User))
        return result.scalars().all()

    async def update(self, user_id: str, data: dict):
        await self.session.execute(update(User).where(User.id == user_id).values(**data))
        await self.session.commit()
        return await self.get_by_id(user_id)

    async def delete(self, user_id: str):
        await self.session.execute(delete(User).where(User.id == user_id))
        await self.session.commit()

--------------------------------------------------------------------------------
FILE: app\database\seed_admin.py
--------------------------------------------------------------------------------
from app.database.user_repository import create_table, create_user

create_table()
create_user("admin@prosolution.com", "admin123")
print("‚úÖ Admin criado")


--------------------------------------------------------------------------------
FILE: app\database\session.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session


--------------------------------------------------------------------------------
FILE: app\database\user_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.context import CryptContext

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_table():
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL
        )
    """)
    conn.commit()
    conn.close()

def create_user(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (email, password) VALUES (?, ?)",
        (email, pwd.hash(password))
    )
    conn.commit()
    conn.close()

def authenticate(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
    user = cursor.fetchone()
    conn.close()

    if user and pwd.verify(password, user["password"]):
        return dict(user)
    return None


--------------------------------------------------------------------------------
FILE: app\database.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

Base = declarative_base()


--------------------------------------------------------------------------------
FILE: app\instagram\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\instagram\client.py
--------------------------------------------------------------------------------
import requests
from app.config import settings

BASE_URL = f"{settings.INSTAGRAM_BASE_URL}/{settings.INSTAGRAM_API_VERSION}"

def create_media(image_url: str, caption: str) -> str:
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media"

    payload = {
        "image_url": image_url,
        "caption": caption,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()["id"]

def publish_media(creation_id: str):
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media_publish"

    payload = {
        "creation_id": creation_id,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()


--------------------------------------------------------------------------------
FILE: app\instagram\post.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from app.instagram.service import publish_image
from app.instagram.schemas import InstagramPostRequest

router = APIRouter()

@router.post("/post")
def post_instagram(data: InstagramPostRequest):
    try:
        return publish_image(data.image_url, data.caption)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


--------------------------------------------------------------------------------
FILE: app\instagram\router.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.instagram.post import router as post_router

router = APIRouter(prefix="/instagram", tags=["Instagram"])
router.include_router(post_router)


--------------------------------------------------------------------------------
FILE: app\instagram\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, HttpUrl, Field

class InstagramPostSchema(BaseModel):
    image_url: HttpUrl = Field(..., example="https://example.com/image.jpg")
    caption: str = Field(..., min_length=1, max_length=2200)

    class Config:
        extra = "forbid"  # evita campos inv√°lidos

from pydantic import BaseModel, HttpUrl


class InstagramPostRequest(BaseModel):
    image_url: HttpUrl
    caption: str

--------------------------------------------------------------------------------
FILE: app\instagram\service.py
--------------------------------------------------------------------------------
from app.instagram.client import create_media, publish_media
from app.config import settings

def publish_image(image_url: str, caption: str):
    if not settings.INSTAGRAM_ACCESS_TOKEN:
        raise RuntimeError("Instagram n√£o configurado")

    creation_id = create_media(image_url, caption)
    return publish_media(creation_id)


--------------------------------------------------------------------------------
FILE: app\instagram\test_token.py
--------------------------------------------------------------------------------
import requests
from app.config import INSTAGRAM_ACCESS_TOKEN

url = "https://graph.facebook.com/v19.0/me"
params = {
    "access_token": INSTAGRAM_ACCESS_TOKEN
}

r = requests.get(url, params=params)
print(r.json())

--------------------------------------------------------------------------------
FILE: app\main.py
--------------------------------------------------------------------------------
from fastapi import FastAPI, Request, Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# Routers
from app.auth.routes import router as auth_router
from app.dashboard.routes import router as dashboard_router
from app.instagram.router import router as instagram_router
from app.ai.routes import router as ai_router
from app.payments.routes import router as payments_router

# Database
from app.database.base import init_db
from app.database.session import get_db
from app.database.repositories.user_repo import UserRepository

app = FastAPI(title="Prosolution API")

# === STARTUP ===
@app.on_event("startup")
async def startup():
    await init_db()

# === STATIC / TEMPLATES ===
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# === HOME ===
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

# === ROUTERS ===
app.include_router(auth_router, prefix="/auth")
app.include_router(dashboard_router)
app.include_router(instagram_router)
app.include_router(ai_router)
app.include_router(payments_router)

# === API TEST ===
@app.get("/api")
async def api_root():
    return {"status": "üöÄ Prosolution API online"}

# === USERS (TESTE) ===
@app.get("/api/users")
async def list_users(db=Depends(get_db)):
    return await UserRepository(db).list_all()


--------------------------------------------------------------------------------
FILE: app\models.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, Boolean
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    password = Column(String)
    is_admin = Column(Boolean, default=False)
    plan = Column(String, default="free")


--------------------------------------------------------------------------------
FILE: app\payments\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\payments\mercadopago_client.py
--------------------------------------------------------------------------------
import httpx
from app.config import settings


class MercadoPagoClient:
    def __init__(self):
        self.base_url = "https://api.mercadopago.com"
        self.headers = {
            "Authorization": f"Bearer {settings.MERCADO_PAGO_ACCESS_TOKEN}",
            "Content-Type": "application/json",
        }

    async def create_payment(self, payload: dict):
        async with httpx.AsyncClient(timeout=20) as client:
            response = await client.post(
                f"{self.base_url}/v1/payments",
                headers=self.headers,
                json=payload,
            )

        return response

--------------------------------------------------------------------------------
FILE: app\payments\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.payments.schemas import PixPaymentSchema
from app.payments.service import create_pix_payment

router = APIRouter(prefix="/payments", tags=["Payments"])


@router.post("/pix")
async def create_pix_payment_route(data: PixPaymentSchema):
    return await create_pix_payment(
        amount=data.amount,
        description=data.description,
        email=data.email,
    )

--------------------------------------------------------------------------------
FILE: app\payments\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, Field
from typing import Optional

# EmailStr protegido (n√£o quebra se faltar depend√™ncia)
try:
    from pydantic import EmailStr
except ImportError:
    EmailStr = str


class PixPaymentSchema(BaseModel):
    name: str = Field(..., min_length=2)
    email: EmailStr
    amount: float = Field(..., gt=0)
    description: Optional[str] = None


--------------------------------------------------------------------------------
FILE: app\payments\service.py
--------------------------------------------------------------------------------
from fastapi import HTTPException
from app.payments.mercadopago_client import MercadoPagoClient

client = MercadoPagoClient()


async def create_pix_payment(amount: float, description: str, email: str):
    payload = {
        "transaction_amount": amount,
        "description": description,
        "payment_method_id": "pix",
        "payer": {
            "email": email
        }
    }

    response = await client.create_payment(payload)
    data = response.json()

    if response.status_code not in (200, 201):
        raise HTTPException(
            status_code=400,
            detail={
                "stage": "mercado_pago_payment",
                "error": data
            }
        )

    transaction_data = data.get("point_of_interaction", {}).get("transaction_data", {})

    return {
        "payment_id": data.get("id"),
        "status": data.get("status"),
        "qr_code": transaction_data.get("qr_code"),
        "qr_code_base64": transaction_data.get("qr_code_base64"),
    }

--------------------------------------------------------------------------------
FILE: app\scheduler\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\scheduler\post_runner.py
--------------------------------------------------------------------------------
from app.ai.content_generator import generate_post
from app.database.post_repository import save_post


def run_post(client_id=None, manual=False):
    content = generate_post()
    source = "fallback" if "fallback" in content.lower() else "openai"
    mode = "manual" if manual else "automatic"

    if client_id:
        save_post(client_id, content, source, mode)

    print("[POST]", content)


--------------------------------------------------------------------------------
FILE: app\scheduler\scheduler.py
--------------------------------------------------------------------------------

from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)


--------------------------------------------------------------------------------
FILE: app\security.py
--------------------------------------------------------------------------------
import os
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password):
    return pwd.hash(password)

def verify_password(password, hashed):
    return pwd.verify(password, hashed)

def create_token(data: dict):
    data["exp"] = datetime.utcnow() + timedelta(hours=2)
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)


--------------------------------------------------------------------------------
FILE: app\utils\security.py
--------------------------------------------------------------------------------
import requests

API_KEY = "SUA_CHAVE_IPQUALITYSCORE"

def is_vpn(ip: str) -> bool:
    url = f"https://ipqualityscore.com/api/json/ip/{API_KEY}/{ip}"
    data = requests.get(url, timeout=5).json()

    return any([
        data.get("vpn"),
        data.get("proxy"),
        data.get("tor"),
        data.get("hosting")
    ])


--------------------------------------------------------------------------------
FILE: app\vpn_block.py
--------------------------------------------------------------------------------
import requests

def is_vpn(ip: str):
    try:
        r = requests.get(f"https://ip-api.com/json/{ip}?fields=proxy,hosting")
        data = r.json()
        return data.get("proxy") or data.get("hosting")
    except:
        return False


--------------------------------------------------------------------------------
FILE: apply_prosolution_fixes.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

ROOT = Path.cwd()

def write(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"‚úî atualizado: {path}")

# ======================================================
# 1Ô∏è‚É£ .env.example (SEGURAN√áA)
# ======================================================
write(ROOT / ".env.example", """
# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution
""")

# ======================================================
# 2Ô∏è‚É£ BANCO DE DADOS ‚Äî UNIFICADO (ASYNC POSTGRES)
# ======================================================
write(ROOT / "app/database/session.py", """
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)
AsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False)
""")

write(ROOT / "app/database/base.py", """
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass
""")

# ======================================================
# 3Ô∏è‚É£ AUTH √öNICA (REMOVE AUTH FAKE)
# ======================================================
write(ROOT / "app/auth/routes.py", """
from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user
""")

# ======================================================
# 4Ô∏è‚É£ IA ‚Äî PADRONIZA√á√ÉO PROVIDERS
# ======================================================
write(ROOT / "app/ai/providers/base.py", """
from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass
""")

write(ROOT / "app/ai/providers/gemini.py", """
import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text
""")

write(ROOT / "app/ai/providers/openai.py", """
from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content
""")

# ======================================================
# 5Ô∏è‚É£ ORQUESTRADOR IA (√öNICO)
# ======================================================
write(ROOT / "app/ai/orchestrator.py", """
from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)
""")

# ======================================================
# 6Ô∏è‚É£ SCHEDULER CORRIGIDO
# ======================================================
write(ROOT / "app/scheduler/scheduler.py", """
from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)
""")

# ======================================================
# 7Ô∏è‚É£ CONFIG CENTRALIZADA
# ======================================================
write(ROOT / "app/config.py", """
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    INSTAGRAM_ACCESS_TOKEN: str = ""
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str = ""
    INSTAGRAM_API_VERSION: str = "v24.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    GEMINI_API_KEY: str = ""
    OPENAI_API_KEY: str = ""

    DATABASE_URL: str = ""

    class Config:
        env_file = ".env"

settings = Settings()
""")

print("\\n‚úÖ TODAS AS CORRE√á√ïES FORAM APLICADAS COM SUCESSO")


--------------------------------------------------------------------------------
FILE: apply_prosolution_runtime_fixes.py
--------------------------------------------------------------------------------
import subprocess
import sys
from pathlib import Path

BASE = Path(__file__).parent
REQ = BASE / "requirements.txt"

REQUIRED_PACKAGES = [
    "email-validator",
    "pydantic[email]",
]

def run(cmd):
    print(f"‚ñ∂ {cmd}")
    subprocess.check_call(cmd, shell=True)

def ensure_requirements():
    content = REQ.read_text(encoding="utf-8")

    updated = False
    for pkg in REQUIRED_PACKAGES:
        if pkg.split("[")[0] not in content:
            content += f"\n{pkg}"
            updated = True

    if updated:
        REQ.write_text(content, encoding="utf-8")
        print("‚úî requirements.txt atualizado")
    else:
        print("‚Ñπ requirements.txt j√° estava correto")

def install():
    run(f"{sys.executable} -m pip install --upgrade pip")
    run(f"{sys.executable} -m pip install -r requirements.txt")

def patch_email_schema():
    schemas = BASE / "app" / "payments" / "schemas.py"
    if not schemas.exists():
        return

    txt = schemas.read_text(encoding="utf-8")

    if "EmailStr" in txt:
        txt = txt.replace(
            "from pydantic import BaseModel, EmailStr",
            "from pydantic import BaseModel\nfrom typing import Optional\n\n# EmailStr protegido\ntry:\n    from pydantic import EmailStr\nexcept ImportError:\n    EmailStr = str"
        )
        schemas.write_text(txt, encoding="utf-8")
        print("‚úî Schema de pagamento protegido contra crash")

def main():
    print("\nüöÄ APLICANDO FIXES DEFINITIVOS (PROSOLUTION)\n")
    ensure_requirements()
    install()
    patch_email_schema()
    print("\n‚úÖ SISTEMA PRONTO PARA SUBIR")

if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: dump_prosolution.py
--------------------------------------------------------------------------------
from pathlib import Path

BASE_DIR = Path(__file__).parent
OUTPUT_FILE = BASE_DIR / "prosolution_full_dump.txt"

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    ".idea",
    ".vscode",
    "node_modules",
}

INCLUDE_EXTENSIONS = {
    ".py",
    ".txt",
    ".md",
    ".html",
    ".css",
    ".js",
    ".env",
    ".example",
}


def should_include(path: Path) -> bool:
    if any(part in EXCLUDE_DIRS for part in path.parts):
        return False
    if path.is_file() and path.suffix.lower() in INCLUDE_EXTENSIONS:
        return True
    return False


def main():
    lines = []
    lines.append("=" * 80)
    lines.append("PROSOLUTION IA ‚Äî FULL PROJECT DUMP")
    lines.append("=" * 80)
    lines.append(f"Base path: {BASE_DIR}")
    lines.append("")

    for file_path in sorted(BASE_DIR.rglob("*")):
        if should_include(file_path):
            rel = file_path.relative_to(BASE_DIR)
            lines.append("\n" + "-" * 80)
            lines.append(f"FILE: {rel}")
            lines.append("-" * 80)
            try:
                content = file_path.read_text(encoding="utf-8", errors="ignore")
                lines.append(content)
            except Exception as e:
                lines.append(f"[ERROR READING FILE]: {e}")

    OUTPUT_FILE.write_text("\n".join(lines), encoding="utf-8")
    print(f"‚úÖ Dump gerado com sucesso: {OUTPUT_FILE}")


if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: prosolution_full_dump.txt
--------------------------------------------------------------------------------
================================================================================
PROSOLUTION IA ‚Äî FULL PROJECT DUMP
================================================================================
Base path: C:\Users\eduar\Desktop\Api-prosolution-main


--------------------------------------------------------------------------------
FILE: .env.example
--------------------------------------------------------------------------------

# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution


--------------------------------------------------------------------------------
FILE: app\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\ai\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\ai\admin\policies.py
--------------------------------------------------------------------------------
FORBIDDEN_MARKETING_TOPICS = [
    "politica", "religiao", "ideologia", "lgbt",
    "orientacao sexual", "identidade de genero",
    "violencia", "odio", "seguranca publica",
    "armas", "saude sensivel"
]

def is_forbidden_topic(text: str) -> bool:
    text = text.lower()
    return any(topic in text for topic in FORBIDDEN_MARKETING_TOPICS)


--------------------------------------------------------------------------------
FILE: app\ai\admin\prompts.py
--------------------------------------------------------------------------------
SYSTEM_ADMIN_PROMPT = '''
Voc√™ √© a IA ADMINISTRADORA GERAL (AI GOVERNANCE ADMIN).

Voc√™ N√ÉO executa c√≥digo.
Voc√™ N√ÉO altera arquivos.
Voc√™ N√ÉO faz deploy.

Seu papel:
- Avaliar seguran√ßa
- Avaliar c√≥digo
- Avaliar LGPD
- Avaliar riscos jur√≠dicos
- Avaliar bugs prov√°veis
- Avaliar depend√™ncias

No final gere UM PROMPT com:
üî¥ OBRIGAT√ìRIO
üü° NECESS√ÅRIO
üü¢ MELHORIAS OPCIONAIS
'''


--------------------------------------------------------------------------------
FILE: app\ai\admin\system_admin.py
--------------------------------------------------------------------------------
from app.ai.providers.openai import OpenAIProvider
from app.ai.providers.gemini import GeminiProvider
from app.ai.admin.prompts import SYSTEM_ADMIN_PROMPT

openai = OpenAIProvider()
gemini = GeminiProvider()

def evaluate_system(system_snapshot: dict) -> str:
    tech = openai.generate(f"Analise tecnicamente:\n{system_snapshot}")
    product = gemini.generate(f"Avalie produto e UX:\n{system_snapshot}")

    final = openai.generate(
        SYSTEM_ADMIN_PROMPT +
        "\nAN√ÅLISE T√âCNICA:\n" + tech +
        "\nAN√ÅLISE PRODUTO:\n" + product
    )
    return final


--------------------------------------------------------------------------------
FILE: app\ai\chatgpt_service.py
--------------------------------------------------------------------------------
import httpx
from app.config import OPENAI_API_KEY

OPENAI_URL = "https://api.openai.com/v1/chat/completions"

async def generate_with_chatgpt(prompt: str):
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "gpt-4o-mini",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.7
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(OPENAI_URL, headers=headers, json=payload)

    data = res.json()
    return data["choices"][0]["message"]["content"]

--------------------------------------------------------------------------------
FILE: app\ai\content_generator.py
--------------------------------------------------------------------------------
from app.ai.gemini_service import generate_with_gemini
from app.ai.chatgpt_service import generate_with_chatgpt

async def generate_content(niche: str, objective: str):
    prompt = f"""
Crie uma legenda para Instagram.
Nicho: {niche}
Objetivo: {objective}
Inclua hashtags.
"""

    try:
        return await generate_with_gemini(prompt)
    except:
        return await generate_with_chatgpt(prompt)

--------------------------------------------------------------------------------
FILE: app\ai\gemini_service.py
--------------------------------------------------------------------------------
import httpx
from fastapi import HTTPException
from app.config import GEMINI_API_KEY

GEMINI_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent"

async def generate_with_gemini(prompt: str):
    payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(
            GEMINI_URL,
            params={"key": GEMINI_API_KEY},
            json=payload
        )

    data = res.json()

    if res.status_code != 200:
        raise HTTPException(400, data)

    return data["candidates"][0]["content"]["parts"][0]["text"]

--------------------------------------------------------------------------------
FILE: app\ai\orchestrator.py
--------------------------------------------------------------------------------

from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)


--------------------------------------------------------------------------------
FILE: app\ai\providers\base.py
--------------------------------------------------------------------------------

from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass


--------------------------------------------------------------------------------
FILE: app\ai\providers\gemini.py
--------------------------------------------------------------------------------

import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text


--------------------------------------------------------------------------------
FILE: app\ai\providers\openai.py
--------------------------------------------------------------------------------

from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content


--------------------------------------------------------------------------------
FILE: app\ai\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.ai.orchestrator import generate_instagram_content
from app.ai.admin.system_admin import evaluate_system

router = APIRouter(prefix="/ai", tags=["AI"])

@router.post("/instagram-content")
def instagram_content(topic: str):
    return generate_instagram_content(topic)

@router.post("/admin-review")
def admin_review(system_snapshot: dict):
    return {"admin_prompt": evaluate_system(system_snapshot)}


--------------------------------------------------------------------------------
FILE: app\ai\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel

class GeminiInstagramSchema(BaseModel):
    niche: str
    objective: str
    language: str = "pt-BR"

--------------------------------------------------------------------------------
FILE: app\auth\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\auth\routes.py
--------------------------------------------------------------------------------

from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user


--------------------------------------------------------------------------------
FILE: app\auth\security.py
--------------------------------------------------------------------------------
from fastapi import Depends, HTTPException, status

async def get_current_user():
    # üîê Placeholder simples (n√£o quebra o sistema)
    return {"role": "admin"}


--------------------------------------------------------------------------------
FILE: app\auth.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models import User
from app.security import verify_password, create_token
from app.vpn_block import is_vpn

router = APIRouter()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.post("/login")
def login(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    ip = request.client.host
    if is_vpn(ip):
        return {"error": "VPN/Proxy bloqueado"}

    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.password):
        return {"error": "Credenciais inv√°lidas"}

    token = create_token({
        "sub": user.email,
        "admin": user.is_admin,
        "plan": user.plan
    })

    resp = RedirectResponse("/dashboard", 302)
    resp.set_cookie("token", token, httponly=True)
    return resp
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates")

@router.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})


--------------------------------------------------------------------------------
FILE: app\config.py
--------------------------------------------------------------------------------
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    # === APP ===
    ENV: str = "development"

    # === DATABASE ===
    DATABASE_URL: str = "sqlite+aiosqlite:///./prosolution.db"
    DB_ECHO: bool = False
    DB_POOL_SIZE: int = 10

    # === AUTH / SECURITY ===
    SECRET_KEY: str = "CHANGE_ME"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60 * 24

    # === OPENAI ===
    OPENAI_API_KEY: str | None = None

    # === GEMINI ===
    GEMINI_API_KEY: str | None = None

    # === INSTAGRAM ===
    INSTAGRAM_ACCESS_TOKEN: str | None = None
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str | None = None
    INSTAGRAM_API_VERSION: str = "v19.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    # === MERCADO PAGO ===
    MERCADO_PAGO_ACCESS_TOKEN: str | None = None
    MERCADO_PAGO_WEBHOOK_SECRET: str | None = None

    # === Pydantic v2 config ===
    model_config = SettingsConfigDict(
        env_file=".env",
        extra="ignore",  # <<< ISSO EVITA ERROS DE VARI√ÅVEIS A MAIS
    )


settings = Settings()


--------------------------------------------------------------------------------
FILE: app\dashboard\__init__.py
--------------------------------------------------------------------------------
from .routes import router

--------------------------------------------------------------------------------
FILE: app\dashboard\metrics.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.dashboard.repository import get_dashboard_metrics

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])

@router.get("/metrics")
async def metrics():
    return await get_dashboard_metrics()


--------------------------------------------------------------------------------
FILE: app\dashboard\repository.py
--------------------------------------------------------------------------------
from sqlalchemy import select, func
from app.database.session import AsyncSessionLocal
from app.database.models.dashboard import Post, Payment, AILog

async def get_dashboard_metrics():
    async with AsyncSessionLocal() as session:
        posts_total = await session.scalar(select(func.count(Post.id)))
        payments_total = await session.scalar(select(func.count(Payment.id)))
        revenue_total = await session.scalar(select(func.coalesce(func.sum(Payment.amount), 0)))
        last_post = await session.scalar(
            select(Post.caption).order_by(Post.created_at.desc())
        )
        last_ai_action = await session.scalar(
            select(AILog.action).order_by(AILog.created_at.desc())
        )

        return {
            "posts_total": posts_total or 0,
            "payments_total": payments_total or 0,
            "revenue_total": float(revenue_total or 0),
            "last_post": last_post,
            "last_ai_action": last_ai_action,
        }


--------------------------------------------------------------------------------
FILE: app\dashboard\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.templating import Jinja2Templates
from datetime import datetime
import requests

router = APIRouter(prefix="/dashboard", tags=["Dashboard"])
templates = Jinja2Templates(directory="templates")

@router.get("/")
def dashboard(request: Request):
    ip = request.client.host

    try:
        geo = requests.get(f"https://ipapi.co/{ip}/json/").json()
    except:
        geo = {}

    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "ip": ip,
            "city": geo.get("city", "Unknown"),
            "country": geo.get("country_name", "Unknown"),
            "org": geo.get("org", "Unknown"),
            "datetime": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "vpn_status": "OFF"
        }
    )


--------------------------------------------------------------------------------
FILE: app\dashboard.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from jose import jwt
import os

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    token = request.cookies.get("token")
    if not token:
        return {"error": "N√£o autenticado"}

    data = jwt.decode(token, os.getenv("SECRET_KEY"), algorithms=["HS256"])
    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "user": data}
    )



--------------------------------------------------------------------------------
FILE: app\database\__init__.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "sqlite:///./prosolution.db"
)

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
    if DATABASE_URL.startswith("sqlite")
    else {}
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\app\database\models\user.py
--------------------------------------------------------------------------------
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from app.database.base import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)

--------------------------------------------------------------------------------
FILE: app\database\automation_repository.py
--------------------------------------------------------------------------------
import sqlite3

DB_PATH = "app/database/database.db"


def init_automation_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS automation_config (
            id INTEGER PRIMARY KEY,
            enabled BOOLEAN,
            times TEXT
        )
    """)

    cursor.execute("""
        INSERT OR IGNORE INTO automation_config (id, enabled, times)
        VALUES (1, 0, '')
    """)

    conn.commit()
    conn.close()


def save_config(enabled, times):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE automation_config
        SET enabled = ?, times = ?
        WHERE id = 1
    """, (enabled, ",".join(times)))

    conn.commit()
    conn.close()


--------------------------------------------------------------------------------
FILE: app\database\base.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.models import Base

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


--------------------------------------------------------------------------------
FILE: app\database\client_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.hash import bcrypt

def init_clients_table():
    conn = get_connection()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            email TEXT UNIQUE,
            password_hash TEXT,
            plan TEXT
        )
    """)

    # üëë cria admin se n√£o existir
    cursor.execute(
        "SELECT id FROM clients WHERE email = ?",
        ("admin@admin.com",)
    )

    if not cursor.fetchone():
        cursor.execute("""
            INSERT INTO clients (name, email, password_hash, plan)
            VALUES (?, ?, ?, ?)
        """, (
            "Administrador",
            "admin@admin.com",
            bcrypt.hash("123456"),
            "admin"
        ))

    conn.commit()
    conn.close()

from app.database.db import get_session
from app.database.models import Client
from app.auth.security import hash_password


def ensure_admin_exists():
    session = get_session()

    try:
        admin = session.query(Client).filter(
            Client.email == "admin@admin.com"
        ).first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=hash_password("123456"),
                plan="admin",
                active=True
            )
            session.add(admin)
            session.commit()
            print("[BOOTSTRAP] Admin criado com sucesso")
        else:
            print("[BOOTSTRAP] Admin j√° existe")

    finally:
        session.close()

def create_admin_if_not_exists():
    db = SessionLocal()
    try:
        admin = db.query(Client).filter(Client.email == "admin@admin.com").first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=get_password_hash("123456"),
                plan="admin"
            )
            db.add(admin)
            db.commit()
            print("‚úÖ Admin criado com sucesso")
        else:
            print("‚ÑπÔ∏è Admin j√° existe")

    finally:
        db.close()

--------------------------------------------------------------------------------
FILE: app\database\db.py
--------------------------------------------------------------------------------
import sqlite3

DB_NAME = "database.db"

def get_connection():
    conn = sqlite3.connect(DB_NAME, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn


--------------------------------------------------------------------------------
FILE: app\database\migrations\env.py
--------------------------------------------------------------------------------
from app.database.session import engine
from app.database.base import Base
target_metadata = Base.metadata

def run_migrations_online():
    from alembic import context
    connectable = engine.sync_engine
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

--------------------------------------------------------------------------------
FILE: app\database\models\__init__.py
--------------------------------------------------------------------------------
 from app.database.models.base import Base

# Importar models para o SQLAlchemy registrar
from app.database.models.user import User
from app.database.models.post import Post


--------------------------------------------------------------------------------
FILE: app\database\models\base.py
--------------------------------------------------------------------------------
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    pass


--------------------------------------------------------------------------------
FILE: app\database\models\dashboard.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, DateTime, Numeric
from sqlalchemy.sql import func
from app.database.base import Base

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True)
    instagram_id = Column(String, unique=True)
    caption = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class Payment(Base):
    __tablename__ = "payments"

    id = Column(Integer, primary_key=True)
    mp_payment_id = Column(String, unique=True)
    status = Column(String)
    amount = Column(Numeric)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


class AILog(Base):
    __tablename__ = "ai_logs"

    id = Column(Integer, primary_key=True)
    action = Column(String)
    provider = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())


--------------------------------------------------------------------------------
FILE: app\database\models\post.py
--------------------------------------------------------------------------------
from sqlalchemy import String, Text
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class Post(Base):
    __tablename__ = "posts"

    id: Mapped[int] = mapped_column(primary_key=True)
    content: Mapped[str] = mapped_column(Text)


--------------------------------------------------------------------------------
FILE: app\database\models\user.py
--------------------------------------------------------------------------------
from sqlalchemy import String
from sqlalchemy.orm import Mapped, mapped_column
from app.database.models.base import Base


class User(Base):
    __tablename__ = "users"

    id: Mapped[int] = mapped_column(primary_key=True)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    password_hash: Mapped[str]


--------------------------------------------------------------------------------
FILE: app\database\post_repository.py
--------------------------------------------------------------------------------
import sqlite3
from datetime import datetime

DB_PATH = "app/database/database.db"


def init_posts_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            client_id INTEGER,
            content TEXT,
            source TEXT,
            mode TEXT,
            created_at TEXT
        )
    """)

    conn.commit()
    conn.close()


def save_post(client_id, content, source, mode):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO posts (client_id, content, source, mode, created_at)
        VALUES (?, ?, ?, ?, ?)
    """, (client_id, content, source, mode, datetime.now().isoformat()))

    conn.commit()
    conn.close()


def list_posts(client_id, limit=50):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT content, source, mode, created_at
        FROM posts
        WHERE client_id = ?
        ORDER BY id DESC
        LIMIT ?
    """, (client_id, limit))

    rows = cursor.fetchall()
    conn.close()
    return rows


--------------------------------------------------------------------------------
FILE: app\database\repositories\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\database\repositories\post_repository.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from app.database.models.post import InstagramPost

async def save_post(
    db: AsyncSession,
    instagram_id: str,
    image_url: str,
    caption: str
):
    post = InstagramPost(
        instagram_id=instagram_id,
        image_url=image_url,
        caption=caption
    )
    db.add(post)
    await db.commit()
    await db.refresh(post)
    return post

--------------------------------------------------------------------------------
FILE: app\database\repositories\user_repo.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from app.database.models.user import User

class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, user_data: dict) -> User:
        user = User(**user_data)
        self.session.add(user)
        await self.session.commit()
        await self.session.refresh(user)
        return user

    async def get_by_id(self, user_id: str):
        result = await self.session.execute(select(User).filter_by(id=user_id))
        return result.scalars().first()

    async def get_by_email(self, email: str):
        result = await self.session.execute(select(User).filter_by(email=email))
        return result.scalars().first()

    async def list_all(self):
        result = await self.session.execute(select(User))
        return result.scalars().all()

    async def update(self, user_id: str, data: dict):
        await self.session.execute(update(User).where(User.id == user_id).values(**data))
        await self.session.commit()
        return await self.get_by_id(user_id)

    async def delete(self, user_id: str):
        await self.session.execute(delete(User).where(User.id == user_id))
        await self.session.commit()

--------------------------------------------------------------------------------
FILE: app\database\seed_admin.py
--------------------------------------------------------------------------------
from app.database.user_repository import create_table, create_user

create_table()
create_user("admin@prosolution.com", "admin123")
print("‚úÖ Admin criado")


--------------------------------------------------------------------------------
FILE: app\database\session.py
--------------------------------------------------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session


--------------------------------------------------------------------------------
FILE: app\database\user_repository.py
--------------------------------------------------------------------------------
from app.database.db import get_connection
from passlib.context import CryptContext

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_table():
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL
        )
    """)
    conn.commit()
    conn.close()

def create_user(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (email, password) VALUES (?, ?)",
        (email, pwd.hash(password))
    )
    conn.commit()
    conn.close()

def authenticate(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
    user = cursor.fetchone()
    conn.close()

    if user and pwd.verify(password, user["password"]):
        return dict(user)
    return None


--------------------------------------------------------------------------------
FILE: app\database.py
--------------------------------------------------------------------------------
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

Base = declarative_base()


--------------------------------------------------------------------------------
FILE: app\instagram\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\instagram\client.py
--------------------------------------------------------------------------------
import requests
from app.config import settings

BASE_URL = f"{settings.INSTAGRAM_BASE_URL}/{settings.INSTAGRAM_API_VERSION}"

def create_media(image_url: str, caption: str) -> str:
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media"

    payload = {
        "image_url": image_url,
        "caption": caption,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()["id"]

def publish_media(creation_id: str):
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media_publish"

    payload = {
        "creation_id": creation_id,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    r = requests.post(url, data=payload, timeout=30)

    if r.status_code != 200:
        raise RuntimeError(r.text)

    return r.json()


--------------------------------------------------------------------------------
FILE: app\instagram\post.py
--------------------------------------------------------------------------------
from fastapi import APIRouter, HTTPException
from app.instagram.service import publish_image
from app.instagram.schemas import InstagramPostRequest

router = APIRouter()

@router.post("/post")
def post_instagram(data: InstagramPostRequest):
    try:
        return publish_image(data.image_url, data.caption)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


--------------------------------------------------------------------------------
FILE: app\instagram\router.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.instagram.post import router as post_router

router = APIRouter(prefix="/instagram", tags=["Instagram"])
router.include_router(post_router)


--------------------------------------------------------------------------------
FILE: app\instagram\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, HttpUrl, Field

class InstagramPostSchema(BaseModel):
    image_url: HttpUrl = Field(..., example="https://example.com/image.jpg")
    caption: str = Field(..., min_length=1, max_length=2200)

    class Config:
        extra = "forbid"  # evita campos inv√°lidos

from pydantic import BaseModel, HttpUrl


class InstagramPostRequest(BaseModel):
    image_url: HttpUrl
    caption: str

--------------------------------------------------------------------------------
FILE: app\instagram\service.py
--------------------------------------------------------------------------------
from app.instagram.client import create_media, publish_media
from app.config import settings

def publish_image(image_url: str, caption: str):
    if not settings.INSTAGRAM_ACCESS_TOKEN:
        raise RuntimeError("Instagram n√£o configurado")

    creation_id = create_media(image_url, caption)
    return publish_media(creation_id)


--------------------------------------------------------------------------------
FILE: app\instagram\test_token.py
--------------------------------------------------------------------------------
import requests
from app.config import INSTAGRAM_ACCESS_TOKEN

url = "https://graph.facebook.com/v19.0/me"
params = {
    "access_token": INSTAGRAM_ACCESS_TOKEN
}

r = requests.get(url, params=params)
print(r.json())

--------------------------------------------------------------------------------
FILE: app\main.py
--------------------------------------------------------------------------------
from fastapi import FastAPI, Request, Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# Routers
from app.auth.routes import router as auth_router
from app.dashboard.routes import router as dashboard_router
from app.instagram.router import router as instagram_router
from app.ai.routes import router as ai_router
from app.payments.routes import router as payments_router

# Database
from app.database.base import init_db
from app.database.session import get_db
from app.database.repositories.user_repo import UserRepository

app = FastAPI(title="Prosolution API")

# === STARTUP ===
@app.on_event("startup")
async def startup():
    await init_db()

# === STATIC / TEMPLATES ===
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# === HOME ===
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

# === ROUTERS ===
app.include_router(auth_router, prefix="/auth")
app.include_router(dashboard_router)
app.include_router(instagram_router)
app.include_router(ai_router)
app.include_router(payments_router)

# === API TEST ===
@app.get("/api")
async def api_root():
    return {"status": "üöÄ Prosolution API online"}

# === USERS (TESTE) ===
@app.get("/api/users")
async def list_users(db=Depends(get_db)):
    return await UserRepository(db).list_all()


--------------------------------------------------------------------------------
FILE: app\models.py
--------------------------------------------------------------------------------
from sqlalchemy import Column, Integer, String, Boolean
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    password = Column(String)
    is_admin = Column(Boolean, default=False)
    plan = Column(String, default="free")


--------------------------------------------------------------------------------
FILE: app\payments\__init__.py
--------------------------------------------------------------------------------
 

--------------------------------------------------------------------------------
FILE: app\payments\mercadopago_client.py
--------------------------------------------------------------------------------
import httpx
from app.config import settings


class MercadoPagoClient:
    def __init__(self):
        self.base_url = "https://api.mercadopago.com"
        self.headers = {
            "Authorization": f"Bearer {settings.MERCADO_PAGO_ACCESS_TOKEN}",
            "Content-Type": "application/json",
        }

    async def create_payment(self, payload: dict):
        async with httpx.AsyncClient(timeout=20) as client:
            response = await client.post(
                f"{self.base_url}/v1/payments",
                headers=self.headers,
                json=payload,
            )

        return response

--------------------------------------------------------------------------------
FILE: app\payments\routes.py
--------------------------------------------------------------------------------
from fastapi import APIRouter
from app.payments.schemas import PixPaymentSchema
from app.payments.service import create_pix_payment

router = APIRouter(prefix="/payments", tags=["Payments"])


@router.post("/pix")
async def create_pix_payment_route(data: PixPaymentSchema):
    return await create_pix_payment(
        amount=data.amount,
        description=data.description,
        email=data.email,
    )

--------------------------------------------------------------------------------
FILE: app\payments\schemas.py
--------------------------------------------------------------------------------
from pydantic import BaseModel, Field
from typing import Optional

# EmailStr protegido (n√£o quebra se faltar depend√™ncia)
try:
    from pydantic import EmailStr
except ImportError:
    EmailStr = str


class PixPaymentSchema(BaseModel):
    name: str = Field(..., min_length=2)
    email: EmailStr
    amount: float = Field(..., gt=0)
    description: Optional[str] = None


--------------------------------------------------------------------------------
FILE: app\payments\service.py
--------------------------------------------------------------------------------
from fastapi import HTTPException
from app.payments.mercadopago_client import MercadoPagoClient

client = MercadoPagoClient()


async def create_pix_payment(amount: float, description: str, email: str):
    payload = {
        "transaction_amount": amount,
        "description": description,
        "payment_method_id": "pix",
        "payer": {
            "email": email
        }
    }

    response = await client.create_payment(payload)
    data = response.json()

    if response.status_code not in (200, 201):
        raise HTTPException(
            status_code=400,
            detail={
                "stage": "mercado_pago_payment",
                "error": data
            }
        )

    transaction_data = data.get("point_of_interaction", {}).get("transaction_data", {})

    return {
        "payment_id": data.get("id"),
        "status": data.get("status"),
        "qr_code": transaction_data.get("qr_code"),
        "qr_code_base64": transaction_data.get("qr_code_base64"),
    }

--------------------------------------------------------------------------------
FILE: app\scheduler\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: app\scheduler\post_runner.py
--------------------------------------------------------------------------------
from app.ai.content_generator import generate_post
from app.database.post_repository import save_post


def run_post(client_id=None, manual=False):
    content = generate_post()
    source = "fallback" if "fallback" in content.lower() else "openai"
    mode = "manual" if manual else "automatic"

    if client_id:
        save_post(client_id, content, source, mode)

    print("[POST]", content)


--------------------------------------------------------------------------------
FILE: app\scheduler\scheduler.py
--------------------------------------------------------------------------------

from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)


--------------------------------------------------------------------------------
FILE: app\security.py
--------------------------------------------------------------------------------
import os
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password):
    return pwd.hash(password)

def verify_password(password, hashed):
    return pwd.verify(password, hashed)

def create_token(data: dict):
    data["exp"] = datetime.utcnow() + timedelta(hours=2)
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)


--------------------------------------------------------------------------------
FILE: app\utils\security.py
--------------------------------------------------------------------------------
import requests

API_KEY = "SUA_CHAVE_IPQUALITYSCORE"

def is_vpn(ip: str) -> bool:
    url = f"https://ipqualityscore.com/api/json/ip/{API_KEY}/{ip}"
    data = requests.get(url, timeout=5).json()

    return any([
        data.get("vpn"),
        data.get("proxy"),
        data.get("tor"),
        data.get("hosting")
    ])


--------------------------------------------------------------------------------
FILE: app\vpn_block.py
--------------------------------------------------------------------------------
import requests

def is_vpn(ip: str):
    try:
        r = requests.get(f"https://ip-api.com/json/{ip}?fields=proxy,hosting")
        data = r.json()
        return data.get("proxy") or data.get("hosting")
    except:
        return False


--------------------------------------------------------------------------------
FILE: apply_prosolution_fixes.py
--------------------------------------------------------------------------------
import os
from pathlib import Path

ROOT = Path.cwd()

def write(path: Path, content: str):
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(content, encoding="utf-8")
    print(f"‚úî atualizado: {path}")

# ======================================================
# 1Ô∏è‚É£ .env.example (SEGURAN√áA)
# ======================================================
write(ROOT / ".env.example", """
# INSTAGRAM
INSTAGRAM_ACCESS_TOKEN=
INSTAGRAM_BUSINESS_ACCOUNT_ID=
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# IA
GEMINI_API_KEY=
OPENAI_API_KEY=

# DATABASE
DATABASE_URL=postgresql+asyncpg://user:password@localhost/prosolution
""")

# ======================================================
# 2Ô∏è‚É£ BANCO DE DADOS ‚Äî UNIFICADO (ASYNC POSTGRES)
# ======================================================
write(ROOT / "app/database/session.py", """
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from app.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False)
AsyncSessionLocal = async_sessionmaker(engine, expire_on_commit=False)
""")

write(ROOT / "app/database/base.py", """
from sqlalchemy.orm import DeclarativeBase

class Base(DeclarativeBase):
    pass
""")

# ======================================================
# 3Ô∏è‚É£ AUTH √öNICA (REMOVE AUTH FAKE)
# ======================================================
write(ROOT / "app/auth/routes.py", """
from fastapi import APIRouter, Depends
from app.auth.security import get_current_user

router = APIRouter(prefix="/auth", tags=["Auth"])

@router.get("/me")
async def me(user=Depends(get_current_user)):
    return user
""")

# ======================================================
# 4Ô∏è‚É£ IA ‚Äî PADRONIZA√á√ÉO PROVIDERS
# ======================================================
write(ROOT / "app/ai/providers/base.py", """
from abc import ABC, abstractmethod

class AIProvider(ABC):
    @abstractmethod
    def generate(self, prompt: str) -> str:
        pass
""")

write(ROOT / "app/ai/providers/gemini.py", """
import google.generativeai as genai
from app.config import settings
from app.ai.providers.base import AIProvider

genai.configure(api_key=settings.GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text
""")

write(ROOT / "app/ai/providers/openai.py", """
from openai import OpenAI
from app.config import settings
from app.ai.providers.base import AIProvider

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        client = OpenAI(api_key=settings.OPENAI_API_KEY)
        res = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return res.choices[0].message.content
""")

# ======================================================
# 5Ô∏è‚É£ ORQUESTRADOR IA (√öNICO)
# ======================================================
write(ROOT / "app/ai/orchestrator.py", """
from app.ai.providers.gemini import GeminiProvider

def generate_instagram_content(prompt: str) -> str:
    provider = GeminiProvider()
    return provider.generate(prompt)
""")

# ======================================================
# 6Ô∏è‚É£ SCHEDULER CORRIGIDO
# ======================================================
write(ROOT / "app/scheduler/scheduler.py", """
from app.ai.orchestrator import generate_instagram_content

def run():
    content = generate_instagram_content("Post institucional")
    print(content)
""")

# ======================================================
# 7Ô∏è‚É£ CONFIG CENTRALIZADA
# ======================================================
write(ROOT / "app/config.py", """
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    INSTAGRAM_ACCESS_TOKEN: str = ""
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str = ""
    INSTAGRAM_API_VERSION: str = "v24.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    GEMINI_API_KEY: str = ""
    OPENAI_API_KEY: str = ""

    DATABASE_URL: str = ""

    class Config:
        env_file = ".env"

settings = Settings()
""")

print("\\n‚úÖ TODAS AS CORRE√á√ïES FORAM APLICADAS COM SUCESSO")


--------------------------------------------------------------------------------
FILE: apply_prosolution_runtime_fixes.py
--------------------------------------------------------------------------------
import subprocess
import sys
from pathlib import Path

BASE = Path(__file__).parent
REQ = BASE / "requirements.txt"

REQUIRED_PACKAGES = [
    "email-validator",
    "pydantic[email]",
]

def run(cmd):
    print(f"‚ñ∂ {cmd}")
    subprocess.check_call(cmd, shell=True)

def ensure_requirements():
    content = REQ.read_text(encoding="utf-8")

    updated = False
    for pkg in REQUIRED_PACKAGES:
        if pkg.split("[")[0] not in content:
            content += f"\n{pkg}"
            updated = True

    if updated:
        REQ.write_text(content, encoding="utf-8")
        print("‚úî requirements.txt atualizado")
    else:
        print("‚Ñπ requirements.txt j√° estava correto")

def install():
    run(f"{sys.executable} -m pip install --upgrade pip")
    run(f"{sys.executable} -m pip install -r requirements.txt")

def patch_email_schema():
    schemas = BASE / "app" / "payments" / "schemas.py"
    if not schemas.exists():
        return

    txt = schemas.read_text(encoding="utf-8")

    if "EmailStr" in txt:
        txt = txt.replace(
            "from pydantic import BaseModel, EmailStr",
            "from pydantic import BaseModel\nfrom typing import Optional\n\n# EmailStr protegido\ntry:\n    from pydantic import EmailStr\nexcept ImportError:\n    EmailStr = str"
        )
        schemas.write_text(txt, encoding="utf-8")
        print("‚úî Schema de pagamento protegido contra crash")

def main():
    print("\nüöÄ APLICANDO FIXES DEFINITIVOS (PROSOLUTION)\n")
    ensure_requirements()
    install()
    patch_email_schema()
    print("\n‚úÖ SISTEMA PRONTO PARA SUBIR")

if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: dump_prosolution.py
--------------------------------------------------------------------------------
from pathlib import Path

BASE_DIR = Path(__file__).parent
OUTPUT_FILE = BASE_DIR / "prosolution_full_dump.txt"

EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    ".idea",
    ".vscode",
    "node_modules",
}

INCLUDE_EXTENSIONS = {
    ".py",
    ".txt",
    ".md",
    ".html",
    ".css",
    ".js",
    ".env",
    ".example",
}


def should_include(path: Path) -> bool:
    if any(part in EXCLUDE_DIRS for part in path.parts):
        return False
    if path.is_file() and path.suffix.lower() in INCLUDE_EXTENSIONS:
        return True
    return False


def main():
    lines = []
    lines.append("=" * 80)
    lines.append("PROSOLUTION IA ‚Äî FULL PROJECT DUMP")
    lines.append("=" * 80)
    lines.append(f"Base path: {BASE_DIR}")
    lines.append("")

    for file_path in sorted(BASE_DIR.rglob("*")):
        if should_include(file_path):
            rel = file_path.relative_to(BASE_DIR)
            lines.append("\n" + "-" * 80)
            lines.append(f"FILE: {rel}")
            lines.append("-" * 80)
            try:
                content = file_path.read_text(encoding="utf-8", errors="ignore")
                lines.append(content)
            except Exception as e:
                lines.append(f"[ERROR READING FILE]: {e}")

    OUTPUT_FILE.write_text("\n".join(lines), encoding="utf-8")
    print(f"‚úÖ Dump gerado com sucesso: {OUTPUT_FILE}")


if __name__ == "__main__":
    main()


--------------------------------------------------------------------------------
FILE: prosolution_full_dump.txt
--------------------------------------------------------------------------------
================================================================================
PROSOLUTION IA ‚Äî FULL PROJECT DUMP
Generated at: 2025-12-22 19:33:29.977425
Project root: C:\Users\eduar\Desktop\Api-prosolution-main
================================================================================

PROJECT STRUCTURE
--------------------------------------------------------------------------------
Api-prosolution-main/
  .env
  dump_prosolution.py
  prosolution_full_dump.txt
  README.md
  requirements.txt
  app/
    auth.py
    config.py
    dashboard.py
    database.py
    main.py
    models.py
    security.py
    vpn_block.py
    __init__.py
    ai/
      chatgpt_service.py
      content_generator.py
      gemini_service.py
      orchestrator.py
      routes.py
      schemas.py
      __init__.py
      admin/
        policies.py
        prompts.py
        system_admin.py
      providers/
        base.py
        gemini.py
        openai.py
    auth/
      routes.py
      security.py
      __init__.py
    dashboard/
      routes.py
      __init__.py
    database/
      automation_repository.py
      base.py
      client_repository.py
      db.py
      post_repository.py
      seed_admin.py
      session.py
      user_repository.py
      __init__.py
      app/
        database/
          models/
            user.py
      migrations/
        env.py
      models/
        post.py
        user.py
        __init__.py
      repositories/
        post_repository.py
        user_repo.py
        __init__.py
    instagram/
      client.py
      post.py
      router.py
      schemas.py
      service.py
      test_token.py
      __init__.py
    payments/
      mercadopago_client.py
      routes.py
      schemas.py
      service.py
      __init__.py
    scheduler/
      post_runner.py
      scheduler.py
      __init__.py
    utils/
      security.py
  static/
    css/
      __init__.py
    js/
  templates/

FILE CONTENTS
--------------------------------------------------------------------------------

================================================================================
FILE: .env
================================================================================
# ======================
# INSTAGRAM
# ======================
INSTAGRAM_ACCESS_TOKEN=EAAby2qcqYI4BQYrLGlZC8y4FVv4VjAncps6mk8Loz8NynjLSDJHaosfypCveFUR6c5CnEPjkGcIqWSg8mQcZCJ8oZAidFwCC79ZBdTUpEJphCYLYeGgRKTZAvMpaPzVtwcpWYR6V0pWbLYhr9j7H3C2C8NQV4dx5IEI4ycYF1bQbzmgE6te4R0Ad5KyVoZBCBXKb0Uc4em69QK33cFIEGZAnWh7q2oXDunrHNSWeJIZD
INSTAGRAM_BUSINESS_ACCOUNT_ID=17841479719754804
INSTAGRAM_API_VERSION=v24.0
INSTAGRAM_BASE_URL=https://graph.facebook.com

# ======================
# GEMINI (Google AI)
# ======================
GEMINI_API_KEY=AIzaSyB576pkP8jZdXnIH2qMfL-q710gWMmpob4

DATABASE_URL=postgresql+asyncpg://user:password@localhost:5432/prosolution
DB_ECHO=false
DB_POOL_SIZE=10

MERCADO_PAGO_ACCESS_TOKEN=APP_USR-6557276044940245-122113-ab6845a13a38ab6afa8690b107b8a224-419957141
================================================================================
FILE: dump_prosolution.py
================================================================================
import os
from datetime import datetime

PROJECT_ROOT = os.getcwd()
OUTPUT_FILE = "prosolution_full_dump.txt"

INCLUDE_EXTENSIONS = {".py", ".txt", ".md", ".env", ".example"}
EXCLUDE_DIRS = {
    ".git",
    "__pycache__",
    ".venv",
    "venv",
    "node_modules",
    ".idea",
    ".vscode",
}

def should_include_file(filename):
    return any(filename.endswith(ext) for ext in INCLUDE_EXTENSIONS)

def is_excluded_dir(path):
    return any(part in EXCLUDE_DIRS for part in path.split(os.sep))

def write_header(f):
    f.write("=" * 80 + "\n")
    f.write("PROSOLUTION IA ‚Äî FULL PROJECT DUMP\n")
    f.write(f"Generated at: {datetime.now()}\n")
    f.write(f"Project root: {PROJECT_ROOT}\n")
    f.write("=" * 80 + "\n\n")

def dump_tree(f):
    f.write("PROJECT STRUCTURE\n")
    f.write("-" * 80 + "\n")
    for root, dirs, files in os.walk(PROJECT_ROOT):
        if is_excluded_dir(root):
            continue
        level = root.replace(PROJECT_ROOT, "").count(os.sep)
        indent = "  " * level
        f.write(f"{indent}{os.path.basename(root)}/\n")
        for file in files:
            if should_include_file(file):
                f.write(f"{indent}  {file}\n")
    f.write("\n")

def dump_files(f):
    f.write("FILE CONTENTS\n")
    f.write("-" * 80 + "\n")
    for root, dirs, files in os.walk(PROJECT_ROOT):
        if is_excluded_dir(root):
            continue
        for file in files:
            if should_include_file(file):
                file_path = os.path.join(root, file)
                rel_path = os.path.relpath(file_path, PROJECT_ROOT)
                f.write("\n" + "=" * 80 + "\n")
                f.write(f"FILE: {rel_path}\n")
                f.write("=" * 80 + "\n")
                try:
                    with open(file_path, "r", encoding="utf-8", errors="ignore") as rf:
                        f.write(rf.read())
                except Exception as e:
                    f.write(f"\n[ERROR READING FILE: {e}]\n")

def dump_summary(f):
    file_count = 0
    line_count = 0
    for root, dirs, files in os.walk(PROJECT_ROOT):
        if is_excluded_dir(root):
            continue
        for file in files:
            if should_include_file(file):
                file_count += 1
                try:
                    with open(os.path.join(root, file), "r", encoding="utf-8", errors="ignore") as rf:
                        line_count += sum(1 for _ in rf)
                except:
                    pass

    f.write("\n" + "=" * 80 + "\n")
    f.write("PROJECT SUMMARY\n")
    f.write("=" * 80 + "\n")
    f.write(f"Total files included: {file_count}\n")
    f.write(f"Total lines of code/text: {line_count}\n")

if __name__ == "__main__":
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        write_header(f)
        dump_tree(f)
        dump_files(f)
        dump_summary(f)

    print(f"\n‚úÖ Dump gerado com sucesso: {OUTPUT_FILE}\n")

================================================================================
FILE: prosolution_full_dump.txt
================================================================================

================================================================================
FILE: README.md
================================================================================
# üöÄ Prosolution API ‚Äî SaaS de Automa√ß√£o Inteligente

A **Prosolution API** √© uma plataforma **SaaS backend-first**, desenvolvida com **FastAPI**, focada em **seguran√ßa, automa√ß√£o e escalabilidade**, simulando um produto real pronto para mercado.

Este projeto foi pensado **al√©m do CRUD**, com vis√£o de arquitetura, autentica√ß√£o moderna, controle de usu√°rios, planos e deploy em produ√ß√£o.

---

## üß† Vis√£o do Projeto

O objetivo da Prosolution √© servir como **base s√≥lida para um SaaS profissional**, incluindo:

* Autentica√ß√£o real
* Seguran√ßa por IP
* Controle de usu√°rios e administradores
* Estrutura de monetiza√ß√£o
* C√≥digo limpo e organizado
* Deploy funcional em cloud (Render)

---

## üîê Funcionalidades Implementadas

### ‚úÖ Autentica√ß√£o & Seguran√ßa

* Login real com **PostgreSQL**
* Senhas criptografadas com **bcrypt**
* Autentica√ß√£o via **JWT**
* Sess√£o baseada em token
* Prote√ß√£o de rotas autenticadas
* Redirecionamento autom√°tico ap√≥s login

### üö´ Bloqueio de VPN / Proxy

* Valida√ß√£o de IP do cliente
* Bloqueio de acessos via VPN ou Proxy
* Estrutura pronta para integra√ß√£o com APIs anti-fraude

### üë• Usu√°rios & Admin

* Usu√°rios comuns
* Usu√°rios administradores
* Controle de permiss√µes
* Plano associado ao usu√°rio (free / pro / enterprise)

### üí≥ Monetiza√ß√£o (estrutura pronta)

* Base de planos no banco
* Controle de acesso por plano
* Preparado para Stripe / Mercado Pago

---

## üñ•Ô∏è Interface

* Tela de login moderna
* Dashboard autenticado
* UI estilo terminal / hacker
* Renderiza√ß√£o din√¢mica com dados do usu√°rio (JWT)

---

## üõ†Ô∏è Stack Tecnol√≥gica

* **Python 3.13**
* **FastAPI**
* **PostgreSQL**
* **JWT (python-jose)**
* **Passlib + Bcrypt**
* **Jinja2**
* **Uvicorn**
* **APScheduler**
* **HTML + CSS**
* **Deploy: Render**

---

## üìÇ Estrutura do Projeto

```
app/
‚îú‚îÄ‚îÄ auth/          # Autentica√ß√£o, JWT e seguran√ßa
‚îú‚îÄ‚îÄ dashboard/     # Rotas protegidas e dashboard
‚îú‚îÄ‚îÄ database/      # PostgreSQL e reposit√≥rios
‚îú‚îÄ‚îÄ scheduler/     # Automa√ß√£o e jobs
‚îú‚îÄ‚îÄ utils/         # VPN / Proxy block
‚îú‚îÄ‚îÄ main.py        # Entry point
static/
templates/
requirements.txt
README.md
```

---

## üöÄ Rodando Localmente

```bash
git clone https://github.com/Eduardo09e32y4rhf/Api-prosolution.git
cd Api-prosolution
python -m venv venv
venv\Scripts\activate   # Windows
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Acesse:

```
http://localhost:8000
```

---

## üåç Deploy

Aplica√ß√£o publicada na **Render**, com deploy autom√°tico via GitHub.

---

## üë®‚Äçüíª Sobre o Desenvolvedor

**Jos√© Eduardo da Silva**
üéì Formado em **An√°lise e Desenvolvimento de Sistemas**
üíª Backend Developer ‚Äî APIs, Automa√ß√£o e Seguran√ßa

Experi√™ncia pr√°tica com:

* FastAPI
* Arquitetura backend
* Autentica√ß√£o JWT
* Banco de dados
* Deploy em produ√ß√£o

Este projeto demonstra **capacidade t√©cnica + vis√£o de produto**, indo al√©m de exemplos b√°sicos.

üîó GitHub: [https://github.com/Eduardo09e32y4rhf](https://github.com/Eduardo09e32y4rhf)

---

## ‚≠ê Conclus√£o

A **Prosolution API** √© uma base real para um SaaS moderno, pronta para evolu√ß√£o com:

* Pagamentos reais
* Multi-tenant
* Logs e m√©tricas
* Escala horizontal
* Painel administrativo completo

> C√≥digo limpo, funcional e com vis√£o de mercado.

================================================================================
FILE: requirements.txt
================================================================================
fastapi==0.124.4
uvicorn==0.38.0

SQLAlchemy==2.0.36
greenlet>=3.0.0
asyncpg
aiosqlite
psycopg[binary]>=3.1


python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

python-dotenv==1.2.1
python-multipart==0.0.20

Jinja2==3.1.6
requests==2.32.5
pytz==2025.2
httpx==0.27.0
pydantic-settings
================================================================================
FILE: app\auth.py
================================================================================
from fastapi import APIRouter, Request, Form, Depends
from fastapi.responses import RedirectResponse
from sqlalchemy.orm import Session

from app.database import SessionLocal
from app.models import User
from app.security import verify_password, create_token
from app.vpn_block import is_vpn

router = APIRouter()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@router.post("/login")
def login(
    request: Request,
    email: str = Form(...),
    password: str = Form(...),
    db: Session = Depends(get_db)
):
    ip = request.client.host
    if is_vpn(ip):
        return {"error": "VPN/Proxy bloqueado"}

    user = db.query(User).filter(User.email == email).first()
    if not user or not verify_password(password, user.password):
        return {"error": "Credenciais inv√°lidas"}

    token = create_token({
        "sub": user.email,
        "admin": user.is_admin,
        "plan": user.plan
    })

    resp = RedirectResponse("/dashboard", 302)
    resp.set_cookie("token", token, httponly=True)
    return resp
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates

templates = Jinja2Templates(directory="templates")

@router.get("/login", response_class=HTMLResponse)
def login_page(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

================================================================================
FILE: app\config.py
================================================================================
from pydantic_settings import BaseSettings
from dotenv import load_dotenv
import os

# Carrega vari√°veis do .env
load_dotenv()


class Settings(BaseSettings):
    # === Banco de dados ===
    DATABASE_URL: str
    DB_ECHO: bool = False
    DB_POOL_SIZE: int = 10
    ENV: str = "development"

    # === Configura√ß√µes do Instagram ===
    INSTAGRAM_ACCESS_TOKEN: str
    INSTAGRAM_BUSINESS_ACCOUNT_ID: str
    INSTAGRAM_API_VERSION: str = "v24.0"
    INSTAGRAM_BASE_URL: str = "https://graph.facebook.com"

    # === Configura√ß√µes do Gemini ===
    GEMINI_API_KEY: str

    class Config:
        env_file = ".env"
        extra = "allow"  # Permite vari√°veis extras sem erro


# Inst√¢ncia global para importar em outros m√≥dulos
settings = Settings()


# Vari√°veis de acesso r√°pido (sem precisar chamar settings.xxx)
INSTAGRAM_ACCESS_TOKEN = settings.INSTAGRAM_ACCESS_TOKEN
INSTAGRAM_BUSINESS_ACCOUNT_ID = settings.INSTAGRAM_BUSINESS_ACCOUNT_ID
INSTAGRAM_API_VERSION = settings.INSTAGRAM_API_VERSION
INSTAGRAM_BASE_URL = settings.INSTAGRAM_BASE_URL
GEMINI_API_KEY = settings.GEMINI_API_KEY
import os

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")

================================================================================
FILE: app\dashboard.py
================================================================================
from fastapi import APIRouter, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from jose import jwt
import os

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request):
    token = request.cookies.get("token")
    if not token:
        return {"error": "N√£o autenticado"}

    data = jwt.decode(token, os.getenv("SECRET_KEY"), algorithms=["HS256"])
    return templates.TemplateResponse(
        "dashboard.html",
        {"request": request, "user": data}
    )


================================================================================
FILE: app\database.py
================================================================================
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv("DATABASE_URL")

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

Base = declarative_base()

================================================================================
FILE: app\main.py
================================================================================
from fastapi import FastAPI, Request, Depends
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# === IMPORTS DOS M√ìDULOS ===
from app.auth.routes import router as auth_router
from app.dashboard.routes import router as dashboard_router
from app.instagram.router import router as instagram_router
from app.ai.routes import router as ai_router

# Banco de dados
from app.database.session import get_db
from app.database.repositories.user_repo import UserRepository

# === INICIALIZA O FASTAPI ===
app = FastAPI(title="ProSolution API")

from app.database.base import init_db

@app.on_event("startup")
async def startup_event():
    await init_db()

# === ARQUIVOS EST√ÅTICOS E TEMPLATES ===
app.mount("/static", StaticFiles(directory="static"), name="static")
templates = Jinja2Templates(directory="templates")

# === ROTA PRINCIPAL ===
@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("login.html", {"request": request})

# === ROTEADORES (M√ìDULOS) ===
app.include_router(auth_router, prefix="/auth")
app.include_router(dashboard_router)
app.include_router(instagram_router)
app.include_router(ai_router)

# === ROTEADORES DE BANCO / USERS ===
@app.get("/api")
async def root():
    return {"message": "üöÄ ProSolution API running!"}

@app.get("/api/users")
async def list_users(db=Depends(get_db)):
    repo = UserRepository(db)
    return await repo.list_all()

@app.post("/api/users")
async def create_user(email: str, password_hash: str, db=Depends(get_db)):
    repo = UserRepository(db)
    user = await repo.create({"email": email, "password_hash": password_hash})
    return user

from app.payments.routes import router as payments_router

app.include_router(payments_router)
================================================================================
FILE: app\models.py
================================================================================
from sqlalchemy import Column, Integer, String, Boolean
from app.database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True)
    email = Column(String, unique=True)
    password = Column(String)
    is_admin = Column(Boolean, default=False)
    plan = Column(String, default="free")

================================================================================
FILE: app\security.py
================================================================================
import os
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password):
    return pwd.hash(password)

def verify_password(password, hashed):
    return pwd.verify(password, hashed)

def create_token(data: dict):
    data["exp"] = datetime.utcnow() + timedelta(hours=2)
    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)

================================================================================
FILE: app\vpn_block.py
================================================================================
import requests

def is_vpn(ip: str):
    try:
        r = requests.get(f"https://ip-api.com/json/{ip}?fields=proxy,hosting")
        data = r.json()
        return data.get("proxy") or data.get("hosting")
    except:
        return False

================================================================================
FILE: app\__init__.py
================================================================================

================================================================================
FILE: app\ai\chatgpt_service.py
================================================================================
import httpx
from app.config import OPENAI_API_KEY

OPENAI_URL = "https://api.openai.com/v1/chat/completions"

async def generate_with_chatgpt(prompt: str):
    headers = {
        "Authorization": f"Bearer {OPENAI_API_KEY}",
        "Content-Type": "application/json"
    }

    payload = {
        "model": "gpt-4o-mini",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 0.7
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(OPENAI_URL, headers=headers, json=payload)

    data = res.json()
    return data["choices"][0]["message"]["content"]
================================================================================
FILE: app\ai\content_generator.py
================================================================================
from app.ai.gemini_service import generate_with_gemini
from app.ai.chatgpt_service import generate_with_chatgpt

async def generate_content(niche: str, objective: str):
    prompt = f"""
Crie uma legenda para Instagram.
Nicho: {niche}
Objetivo: {objective}
Inclua hashtags.
"""

    try:
        return await generate_with_gemini(prompt)
    except:
        return await generate_with_chatgpt(prompt)
================================================================================
FILE: app\ai\gemini_service.py
================================================================================
import httpx
from fastapi import HTTPException
from app.config import GEMINI_API_KEY

GEMINI_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent"

async def generate_with_gemini(prompt: str):
    payload = {
        "contents": [{"parts": [{"text": prompt}]}]
    }

    async with httpx.AsyncClient(timeout=30) as client:
        res = await client.post(
            GEMINI_URL,
            params={"key": GEMINI_API_KEY},
            json=payload
        )

    data = res.json()

    if res.status_code != 200:
        raise HTTPException(400, data)

    return data["candidates"][0]["content"]["parts"][0]["text"]
================================================================================
FILE: app\ai\orchestrator.py
================================================================================
from app.ai.providers.gemini import GeminiProvider
from app.ai.providers.openai import OpenAIProvider

gemini = GeminiProvider()
openai = OpenAIProvider()

def generate_instagram_content(topic: str) -> dict:
    base = gemini.generate(f"Crie legenda criativa sobre: {topic}")
    improved = openai.generate(f"Melhore com CTA:\n{base}")
    return {"caption": improved}

================================================================================
FILE: app\ai\routes.py
================================================================================
from fastapi import APIRouter
from app.ai.orchestrator import generate_instagram_content
from app.ai.admin.system_admin import evaluate_system

router = APIRouter(prefix="/ai", tags=["AI"])

@router.post("/instagram-content")
def instagram_content(topic: str):
    return generate_instagram_content(topic)

@router.post("/admin-review")
def admin_review(system_snapshot: dict):
    return {"admin_prompt": evaluate_system(system_snapshot)}

================================================================================
FILE: app\ai\schemas.py
================================================================================
from pydantic import BaseModel

class GeminiInstagramSchema(BaseModel):
    niche: str
    objective: str
    language: str = "pt-BR"
================================================================================
FILE: app\ai\__init__.py
================================================================================
 
================================================================================
FILE: app\ai\admin\policies.py
================================================================================
FORBIDDEN_MARKETING_TOPICS = [
    "politica", "religiao", "ideologia", "lgbt",
    "orientacao sexual", "identidade de genero",
    "violencia", "odio", "seguranca publica",
    "armas", "saude sensivel"
]

def is_forbidden_topic(text: str) -> bool:
    text = text.lower()
    return any(topic in text for topic in FORBIDDEN_MARKETING_TOPICS)

================================================================================
FILE: app\ai\admin\prompts.py
================================================================================
SYSTEM_ADMIN_PROMPT = '''
Voc√™ √© a IA ADMINISTRADORA GERAL (AI GOVERNANCE ADMIN).

Voc√™ N√ÉO executa c√≥digo.
Voc√™ N√ÉO altera arquivos.
Voc√™ N√ÉO faz deploy.

Seu papel:
- Avaliar seguran√ßa
- Avaliar c√≥digo
- Avaliar LGPD
- Avaliar riscos jur√≠dicos
- Avaliar bugs prov√°veis
- Avaliar depend√™ncias

No final gere UM PROMPT com:
üî¥ OBRIGAT√ìRIO
üü° NECESS√ÅRIO
üü¢ MELHORIAS OPCIONAIS
'''

================================================================================
FILE: app\ai\admin\system_admin.py
================================================================================
from app.ai.providers.openai import OpenAIProvider
from app.ai.providers.gemini import GeminiProvider
from app.ai.admin.prompts import SYSTEM_ADMIN_PROMPT

openai = OpenAIProvider()
gemini = GeminiProvider()

def evaluate_system(system_snapshot: dict) -> str:
    tech = openai.generate(f"Analise tecnicamente:\n{system_snapshot}")
    product = gemini.generate(f"Avalie produto e UX:\n{system_snapshot}")

    final = openai.generate(
        SYSTEM_ADMIN_PROMPT +
        "\nAN√ÅLISE T√âCNICA:\n" + tech +
        "\nAN√ÅLISE PRODUTO:\n" + product
    )
    return final

================================================================================
FILE: app\ai\providers\base.py
================================================================================
class AIProvider:
    def generate(self, prompt: str) -> str:
        raise NotImplementedError

================================================================================
FILE: app\ai\providers\gemini.py
================================================================================
import google.generativeai as genai
from app.config import GEMINI_API_KEY
from app.ai.providers.base import AIProvider

genai.configure(api_key=GEMINI_API_KEY)

class GeminiProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        model = genai.GenerativeModel("gemini-pro")
        response = model.generate_content(prompt)
        return response.text.strip()

================================================================================
FILE: app\ai\providers\openai.py
================================================================================
from openai import OpenAI
from app.config import OPENAI_API_KEY
from app.ai.providers.base import AIProvider

client = OpenAI(api_key=OPENAI_API_KEY)

class OpenAIProvider(AIProvider):
    def generate(self, prompt: str) -> str:
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}]
        )
        return response.choices[0].message.content.strip()

================================================================================
FILE: app\auth\routes.py
================================================================================
from fastapi import APIRouter, Request, Form
from fastapi.responses import RedirectResponse
from fastapi.templating import Jinja2Templates

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/login")
def login_page(request: Request):
    return templates.TemplateResponse(
        "login.html",
        {"request": request}
    )

@router.post("/login")
def login(
    email: str = Form(...),
    password: str = Form(...)
):
    # autentica√ß√£o real entra depois
    return RedirectResponse(
        url="/dashboard",
        status_code=302
    )
================================================================================
FILE: app\auth\security.py
================================================================================
from datetime import datetime, timedelta
from jose import jwt

SECRET_KEY = "CHANGE_THIS_SECRET"
ALGORITHM = "HS256"
EXPIRE_MINUTES = 60

def create_access_token(data: dict):
    payload = data.copy()
    payload["exp"] = datetime.utcnow() + timedelta(minutes=EXPIRE_MINUTES)
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
================================================================================
FILE: app\auth\__init__.py
================================================================================
from .routes import router
================================================================================
FILE: app\dashboard\routes.py
================================================================================
from fastapi import APIRouter, Request
from fastapi.templating import Jinja2Templates
from datetime import datetime
import requests

router = APIRouter()
templates = Jinja2Templates(directory="templates")

@router.get("/dashboard")
def dashboard(request: Request):
    ip = request.client.host

    try:
        geo = requests.get(f"https://ipapi.co/{ip}/json/").json()
    except:
        geo = {}

    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "ip": ip,
            "city": geo.get("city", "Unknown"),
            "country": geo.get("country_name", "Unknown"),
            "org": geo.get("org", "Unknown"),
            "datetime": datetime.now().strftime("%d/%m/%Y %H:%M:%S"),
            "vpn_status": "OFF"
        }
    )
================================================================================
FILE: app\dashboard\__init__.py
================================================================================
from .routes import router
================================================================================
FILE: app\database\automation_repository.py
================================================================================
import sqlite3

DB_PATH = "app/database/database.db"


def init_automation_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS automation_config (
            id INTEGER PRIMARY KEY,
            enabled BOOLEAN,
            times TEXT
        )
    """)

    cursor.execute("""
        INSERT OR IGNORE INTO automation_config (id, enabled, times)
        VALUES (1, 0, '')
    """)

    conn.commit()
    conn.close()


def save_config(enabled, times):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        UPDATE automation_config
        SET enabled = ?, times = ?
        WHERE id = 1
    """, (enabled, ",".join(times)))

    conn.commit()
    conn.close()

================================================================================
FILE: app\database\base.py
================================================================================
from app.database.session import Base, engine
from app.database.models.user import User

async def init_db():
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)


from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase

class Base(AsyncAttrs, DeclarativeBase):
    pass
================================================================================
FILE: app\database\client_repository.py
================================================================================
from app.database.db import get_connection
from passlib.hash import bcrypt

def init_clients_table():
    conn = get_connection()
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT,
            email TEXT UNIQUE,
            password_hash TEXT,
            plan TEXT
        )
    """)

    # üëë cria admin se n√£o existir
    cursor.execute(
        "SELECT id FROM clients WHERE email = ?",
        ("admin@admin.com",)
    )

    if not cursor.fetchone():
        cursor.execute("""
            INSERT INTO clients (name, email, password_hash, plan)
            VALUES (?, ?, ?, ?)
        """, (
            "Administrador",
            "admin@admin.com",
            bcrypt.hash("123456"),
            "admin"
        ))

    conn.commit()
    conn.close()

from app.database.db import get_session
from app.database.models import Client
from app.auth.security import hash_password


def ensure_admin_exists():
    session = get_session()

    try:
        admin = session.query(Client).filter(
            Client.email == "admin@admin.com"
        ).first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=hash_password("123456"),
                plan="admin",
                active=True
            )
            session.add(admin)
            session.commit()
            print("[BOOTSTRAP] Admin criado com sucesso")
        else:
            print("[BOOTSTRAP] Admin j√° existe")

    finally:
        session.close()

def create_admin_if_not_exists():
    db = SessionLocal()
    try:
        admin = db.query(Client).filter(Client.email == "admin@admin.com").first()

        if not admin:
            admin = Client(
                name="Administrador",
                email="admin@admin.com",
                password=get_password_hash("123456"),
                plan="admin"
            )
            db.add(admin)
            db.commit()
            print("‚úÖ Admin criado com sucesso")
        else:
            print("‚ÑπÔ∏è Admin j√° existe")

    finally:
        db.close()
================================================================================
FILE: app\database\db.py
================================================================================
import sqlite3

DB_NAME = "database.db"

def get_connection():
    conn = sqlite3.connect(DB_NAME, check_same_thread=False)
    conn.row_factory = sqlite3.Row
    return conn

================================================================================
FILE: app\database\post_repository.py
================================================================================
import sqlite3
from datetime import datetime

DB_PATH = "app/database/database.db"


def init_posts_table():
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        CREATE TABLE IF NOT EXISTS posts (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            client_id INTEGER,
            content TEXT,
            source TEXT,
            mode TEXT,
            created_at TEXT
        )
    """)

    conn.commit()
    conn.close()


def save_post(client_id, content, source, mode):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        INSERT INTO posts (client_id, content, source, mode, created_at)
        VALUES (?, ?, ?, ?, ?)
    """, (client_id, content, source, mode, datetime.now().isoformat()))

    conn.commit()
    conn.close()


def list_posts(client_id, limit=50):
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    cursor.execute("""
        SELECT content, source, mode, created_at
        FROM posts
        WHERE client_id = ?
        ORDER BY id DESC
        LIMIT ?
    """, (client_id, limit))

    rows = cursor.fetchall()
    conn.close()
    return rows

================================================================================
FILE: app\database\seed_admin.py
================================================================================
from app.database.user_repository import create_table, create_user

create_table()
create_user("admin@prosolution.com", "admin123")
print("‚úÖ Admin criado")

================================================================================
FILE: app\database\session.py
================================================================================
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine
from sqlalchemy.orm import sessionmaker
from app.config import settings

engine = create_async_engine(
    settings.DATABASE_URL,
    echo=settings.DB_ECHO,
    pool_pre_ping=True
)

AsyncSessionLocal = sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db():
    async with AsyncSessionLocal() as session:
        yield session
================================================================================
FILE: app\database\user_repository.py
================================================================================
from app.database.db import get_connection
from passlib.context import CryptContext

pwd = CryptContext(schemes=["bcrypt"], deprecated="auto")

def create_table():
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            email TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL
        )
    """)
    conn.commit()
    conn.close()

def create_user(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (email, password) VALUES (?, ?)",
        (email, pwd.hash(password))
    )
    conn.commit()
    conn.close()

def authenticate(email: str, password: str):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM users WHERE email = ?", (email,))
    user = cursor.fetchone()
    conn.close()

    if user and pwd.verify(password, user["password"]):
        return dict(user)
    return None

================================================================================
FILE: app\database\__init__.py
================================================================================
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "sqlite:///./prosolution.db"
)

engine = create_engine(
    DATABASE_URL,
    connect_args={"check_same_thread": False}
    if DATABASE_URL.startswith("sqlite")
    else {}
)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
================================================================================
FILE: app\database\app\database\models\user.py
================================================================================
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime
from sqlalchemy.dialects.postgresql import UUID
from app.database.base import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
================================================================================
FILE: app\database\migrations\env.py
================================================================================
from app.database.session import engine
from app.database.base import Base
target_metadata = Base.metadata

def run_migrations_online():
    from alembic import context
    connectable = engine.sync_engine
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()
================================================================================
FILE: app\database\models\post.py
================================================================================
from sqlalchemy import String, Text, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from datetime import datetime
from app.database.base import Base

class InstagramPost(Base):
    __tablename__ = "instagram_posts"

    id: Mapped[int] = mapped_column(primary_key=True)
    instagram_id: Mapped[str] = mapped_column(String(50))
    image_url: Mapped[str] = mapped_column(Text)
    caption: Mapped[str] = mapped_column(Text)
    created_at: Mapped[datetime] = mapped_column(
        DateTime, default=datetime.utcnow
    )
================================================================================
FILE: app\database\models\user.py
================================================================================
from sqlalchemy import Column, Integer, String
from app.database.session import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    password_hash = Column(String, nullable=False)
================================================================================
FILE: app\database\models\__init__.py
================================================================================
 
================================================================================
FILE: app\database\repositories\post_repository.py
================================================================================
from sqlalchemy.ext.asyncio import AsyncSession
from app.database.models.post import InstagramPost

async def save_post(
    db: AsyncSession,
    instagram_id: str,
    image_url: str,
    caption: str
):
    post = InstagramPost(
        instagram_id=instagram_id,
        image_url=image_url,
        caption=caption
    )
    db.add(post)
    await db.commit()
    await db.refresh(post)
    return post
================================================================================
FILE: app\database\repositories\user_repo.py
================================================================================
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, delete
from app.database.models.user import User

class UserRepository:
    def __init__(self, session: AsyncSession):
        self.session = session

    async def create(self, user_data: dict) -> User:
        user = User(**user_data)
        self.session.add(user)
        await self.session.commit()
        await self.session.refresh(user)
        return user

    async def get_by_id(self, user_id: str):
        result = await self.session.execute(select(User).filter_by(id=user_id))
        return result.scalars().first()

    async def get_by_email(self, email: str):
        result = await self.session.execute(select(User).filter_by(email=email))
        return result.scalars().first()

    async def list_all(self):
        result = await self.session.execute(select(User))
        return result.scalars().all()

    async def update(self, user_id: str, data: dict):
        await self.session.execute(update(User).where(User.id == user_id).values(**data))
        await self.session.commit()
        return await self.get_by_id(user_id)

    async def delete(self, user_id: str):
        await self.session.execute(delete(User).where(User.id == user_id))
        await self.session.commit()
================================================================================
FILE: app\database\repositories\__init__.py
================================================================================
 
================================================================================
FILE: app\instagram\client.py
================================================================================
import requests
from app.config import settings

# üîπ Usa o objeto settings para acessar as vari√°veis do .env
BASE_URL = f"{settings.INSTAGRAM_BASE_URL}/{settings.INSTAGRAM_API_VERSION}"


def create_media(image_url: str, caption: str) -> str:
    """
    Cria um media object (imagem + legenda) no Instagram Graph API.
    Retorna o ID de cria√ß√£o (creation_id) para ser publicado depois.
    """
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media"

    payload = {
        "image_url": image_url,
        "caption": caption,
        "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
    }

    response = requests.post(
        url,
        data=payload,  # application/x-www-form-urlencoded
        timeout=30,
    )

    # ‚ö†Ô∏è Trata erro expl√≠cito da Graph API
    if response.status_code != 200:
        try:
            error_info = response.json().get("error", {})
            raise RuntimeError(
                f"Instagram error {error_info.get('code')}: {error_info.get('message')}"
            )
        except ValueError:
            raise RuntimeError(
                f"Instagram error {response.status_code}: {response.text}"
            )

    data = response.json()
    creation_id = data.get("id")

    if not creation_id:
        raise RuntimeError(f"Instagram response sem id: {data}")

    return creation_id


def publish_media(creation_id: str) -> dict:
    """
    Publica o media object criado anteriormente.
    """
    url = f"{BASE_URL}/{settings.INSTAGRAM_BUSINESS_ACCOUNT_ID}/media_publish"

    response = requests.post(
        url,
        data={
            "creation_id": creation_id,
            "access_token": settings.INSTAGRAM_ACCESS_TOKEN,
        },
        timeout=30,
    )

    response.raise_for_status()
    return response.json()
================================================================================
FILE: app\instagram\post.py
================================================================================
from fastapi import APIRouter, HTTPException
from app.instagram.schemas import InstagramPostRequest
from app.instagram.service import publish_image

router = APIRouter()


@router.post("/post")
def instagram_post(data: InstagramPostRequest):
    try:
        return publish_image(
            image_url=str(data.image_url),  # üëà convers√£o correta
            caption=data.caption,
        )
    except Exception as e:
        # Retorna o erro real (sem mascarar)
        raise HTTPException(status_code=500, detail=str(e))
================================================================================
FILE: app\instagram\router.py
================================================================================
from fastapi import APIRouter
from app.instagram.post import router as post_router

router = APIRouter(
    prefix="/instagram",
    tags=["Instagram"]
)

# inclui o POST /instagram/post
router.include_router(post_router)
================================================================================
FILE: app\instagram\schemas.py
================================================================================
from pydantic import BaseModel, HttpUrl, Field

class InstagramPostSchema(BaseModel):
    image_url: HttpUrl = Field(..., example="https://example.com/image.jpg")
    caption: str = Field(..., min_length=1, max_length=2200)

    class Config:
        extra = "forbid"  # evita campos inv√°lidos

from pydantic import BaseModel, HttpUrl


class InstagramPostRequest(BaseModel):
    image_url: HttpUrl
    caption: str
================================================================================
FILE: app\instagram\service.py
================================================================================
import time
import requests
from app.instagram.client import create_media, publish_media
from app.config import (
    INSTAGRAM_ACCESS_TOKEN,
    INSTAGRAM_BASE_URL,
    INSTAGRAM_API_VERSION,
)

BASE_URL = f"{INSTAGRAM_BASE_URL}/{INSTAGRAM_API_VERSION}"


def publish_image(image_url: str, caption: str) -> dict:
    creation_id = create_media(image_url, caption)

    status_url = f"{BASE_URL}/{creation_id}"

    for _ in range(10):
        response = requests.get(
            status_url,
            params={
                "fields": "status_code",
                "access_token": INSTAGRAM_ACCESS_TOKEN,
            },
            timeout=10,
        )
        response.raise_for_status()

        status = response.json().get("status_code")
        if status == "FINISHED":
            break
        if status == "ERROR":
            raise RuntimeError("Instagram retornou ERROR ao processar a m√≠dia")

        time.sleep(1)
    else:
        raise TimeoutError("Timeout aguardando processamento da m√≠dia")

    return publish_media(creation_id)
================================================================================
FILE: app\instagram\test_token.py
================================================================================
import requests
from app.config import INSTAGRAM_ACCESS_TOKEN

url = "https://graph.facebook.com/v19.0/me"
params = {
    "access_token": INSTAGRAM_ACCESS_TOKEN
}

r = requests.get(url, params=params)
print(r.json())
================================================================================
FILE: app\instagram\__init__.py
================================================================================

================================================================================
FILE: app\payments\mercadopago_client.py
================================================================================
import httpx
from app.config import settings


class MercadoPagoClient:
    def __init__(self):
        self.base_url = "https://api.mercadopago.com"
        self.headers = {
            "Authorization": f"Bearer {settings.MERCADO_PAGO_ACCESS_TOKEN}",
            "Content-Type": "application/json",
        }

    async def create_payment(self, payload: dict):
        async with httpx.AsyncClient(timeout=20) as client:
            response = await client.post(
                f"{self.base_url}/v1/payments",
                headers=self.headers,
                json=payload,
            )

        return response
================================================================================
FILE: app\payments\routes.py
================================================================================
from fastapi import APIRouter
from app.payments.schemas import PixPaymentSchema
from app.payments.service import create_pix_payment

router = APIRouter(prefix="/payments", tags=["Payments"])


@router.post("/pix")
async def create_pix_payment_route(data: PixPaymentSchema):
    return await create_pix_payment(
        amount=data.amount,
        description=data.description,
        email=data.email,
    )
================================================================================
FILE: app\payments\schemas.py
================================================================================
from pydantic import BaseModel, EmailStr, Field


class PixPaymentSchema(BaseModel):
    amount: float = Field(..., gt=0)
    description: str = Field(..., min_length=3)
    email: EmailStr
================================================================================
FILE: app\payments\service.py
================================================================================
from fastapi import HTTPException
from app.payments.mercadopago_client import MercadoPagoClient

client = MercadoPagoClient()


async def create_pix_payment(amount: float, description: str, email: str):
    payload = {
        "transaction_amount": amount,
        "description": description,
        "payment_method_id": "pix",
        "payer": {
            "email": email
        }
    }

    response = await client.create_payment(payload)
    data = response.json()

    if response.status_code not in (200, 201):
        raise HTTPException(
            status_code=400,
            detail={
                "stage": "mercado_pago_payment",
                "error": data
            }
        )

    transaction_data = data.get("point_of_interaction", {}).get("transaction_data", {})

    return {
        "payment_id": data.get("id"),
        "status": data.get("status"),
        "qr_code": transaction_data.get("qr_code"),
        "qr_code_base64": transaction_data.get("qr_code_base64"),
    }
================================================================================
FILE: app\payments\__init__.py
================================================================================
 
================================================================================
FILE: app\scheduler\post_runner.py
================================================================================
from app.ai.content_generator import generate_post
from app.database.post_repository import save_post


def run_post(client_id=None, manual=False):
    content = generate_post()
    source = "fallback" if "fallback" in content.lower() else "openai"
    mode = "manual" if manual else "automatic"

    if client_id:
        save_post(client_id, content, source, mode)

    print("[POST]", content)

================================================================================
FILE: app\scheduler\scheduler.py
================================================================================
from apscheduler.schedulers.asyncio import AsyncIOScheduler

scheduler = AsyncIOScheduler()

def start_scheduler():
    scheduler.start()
================================================================================
FILE: app\scheduler\__init__.py
================================================================================

================================================================================
FILE: app\utils\security.py
================================================================================
import requests

API_KEY = "SUA_CHAVE_IPQUALITYSCORE"

def is_vpn(ip: str) -> bool:
    url = f"https://ipqualityscore.com/api/json/ip/{API_KEY}/{ip}"
    data = requests.get(url, timeout=5).json()

    return any([
        data.get("vpn"),
        data.get("proxy"),
        data.get("tor"),
        data.get("hosting")
    ])

================================================================================
FILE: static\css\__init__.py
================================================================================

================================================================================
PROJECT SUMMARY
================================================================================
Total files included: 66
Total lines of code/text: 1395


--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------
# üöÄ Prosolution API ‚Äî SaaS de Automa√ß√£o Inteligente

A **Prosolution API** √© uma plataforma **SaaS backend-first**, desenvolvida com **FastAPI**, focada em **seguran√ßa, automa√ß√£o e escalabilidade**, simulando um produto real pronto para mercado.

Este projeto foi pensado **al√©m do CRUD**, com vis√£o de arquitetura, autentica√ß√£o moderna, controle de usu√°rios, planos e deploy em produ√ß√£o.

---

## üß† Vis√£o do Projeto

O objetivo da Prosolution √© servir como **base s√≥lida para um SaaS profissional**, incluindo:

* Autentica√ß√£o real
* Seguran√ßa por IP
* Controle de usu√°rios e administradores
* Estrutura de monetiza√ß√£o
* C√≥digo limpo e organizado
* Deploy funcional em cloud (Render)

---

## üîê Funcionalidades Implementadas

### ‚úÖ Autentica√ß√£o & Seguran√ßa

* Login real com **PostgreSQL**
* Senhas criptografadas com **bcrypt**
* Autentica√ß√£o via **JWT**
* Sess√£o baseada em token
* Prote√ß√£o de rotas autenticadas
* Redirecionamento autom√°tico ap√≥s login

### üö´ Bloqueio de VPN / Proxy

* Valida√ß√£o de IP do cliente
* Bloqueio de acessos via VPN ou Proxy
* Estrutura pronta para integra√ß√£o com APIs anti-fraude

### üë• Usu√°rios & Admin

* Usu√°rios comuns
* Usu√°rios administradores
* Controle de permiss√µes
* Plano associado ao usu√°rio (free / pro / enterprise)

### üí≥ Monetiza√ß√£o (estrutura pronta)

* Base de planos no banco
* Controle de acesso por plano
* Preparado para Stripe / Mercado Pago

---

## üñ•Ô∏è Interface

* Tela de login moderna
* Dashboard autenticado
* UI estilo terminal / hacker
* Renderiza√ß√£o din√¢mica com dados do usu√°rio (JWT)

---

## üõ†Ô∏è Stack Tecnol√≥gica

* **Python 3.13**
* **FastAPI**
* **PostgreSQL**
* **JWT (python-jose)**
* **Passlib + Bcrypt**
* **Jinja2**
* **Uvicorn**
* **APScheduler**
* **HTML + CSS**
* **Deploy: Render**

---

## üìÇ Estrutura do Projeto

```
app/
‚îú‚îÄ‚îÄ auth/          # Autentica√ß√£o, JWT e seguran√ßa
‚îú‚îÄ‚îÄ dashboard/     # Rotas protegidas e dashboard
‚îú‚îÄ‚îÄ database/      # PostgreSQL e reposit√≥rios
‚îú‚îÄ‚îÄ scheduler/     # Automa√ß√£o e jobs
‚îú‚îÄ‚îÄ utils/         # VPN / Proxy block
‚îú‚îÄ‚îÄ main.py        # Entry point
static/
templates/
requirements.txt
README.md
```

---

## üöÄ Rodando Localmente

```bash
git clone https://github.com/Eduardo09e32y4rhf/Api-prosolution.git
cd Api-prosolution
python -m venv venv
venv\Scripts\activate   # Windows
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Acesse:

```
http://localhost:8000
```

---

## üåç Deploy

Aplica√ß√£o publicada na **Render**, com deploy autom√°tico via GitHub.

---

## üë®‚Äçüíª Sobre o Desenvolvedor

**Jos√© Eduardo da Silva**
üéì Formado em **An√°lise e Desenvolvimento de Sistemas**
üíª Backend Developer ‚Äî APIs, Automa√ß√£o e Seguran√ßa

Experi√™ncia pr√°tica com:

* FastAPI
* Arquitetura backend
* Autentica√ß√£o JWT
* Banco de dados
* Deploy em produ√ß√£o

Este projeto demonstra **capacidade t√©cnica + vis√£o de produto**, indo al√©m de exemplos b√°sicos.

üîó GitHub: [https://github.com/Eduardo09e32y4rhf](https://github.com/Eduardo09e32y4rhf)

---

## ‚≠ê Conclus√£o

A **Prosolution API** √© uma base real para um SaaS moderno, pronta para evolu√ß√£o com:

* Pagamentos reais
* Multi-tenant
* Logs e m√©tricas
* Escala horizontal
* Painel administrativo completo

> C√≥digo limpo, funcional e com vis√£o de mercado.


--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
fastapi==0.124.4
uvicorn==0.38.0

SQLAlchemy==2.0.36
greenlet>=3.0.0
asyncpg
aiosqlite
psycopg[binary]>=3.1


python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

python-dotenv==1.2.1
python-multipart==0.0.20

Jinja2==3.1.6
requests==2.32.5
pytz==2025.2
httpx==0.27.0
pydantic-settings
email-validator

--------------------------------------------------------------------------------
FILE: static\css\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: static\css\login.css
--------------------------------------------------------------------------------
/* =======================
   PROSOLUTION LOGIN 2.0
   ======================= */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  flex-direction: column;
  color: #111827;
}

/* CONTAINER */
.login-container {
  width: 100%;
  max-width: 420px;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

/* BOX */
.login-box {
  background: #ffffff;
  border-radius: 16px;
  padding: 40px 36px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
  width: 100%;
  text-align: center;
}

.logo {
  font-weight: 700;
  font-size: 1.5rem;
  color: #0f172a;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}

.logo span {
  color: #22c55e;
}

/* TITLES */
.login-box h2 {
  font-size: 1.25rem;
  margin-bottom: 6px;
}

.login-box p {
  color: #6b7280;
  font-size: 0.9rem;
  margin-bottom: 28px;
}

/* FORM */
form {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

input {
  padding: 14px 16px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
  font-size: 0.95rem;
  color: #111827;
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2);
}

/* BUTTON */
button {
  padding: 14px;
  border-radius: 10px;
  background: #22c55e;
  border: none;
  color: white;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

button:hover {
  background: #16a34a;
  box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
}

/* ERROR MESSAGE */
.error {
  margin-top: 14px;
  color: #dc2626;
  background: #fee2e2;
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 0.85rem;
  display: inline-block;
}

/* FOOTER */
footer {
  margin-top: 30px;
  font-size: 0.8rem;
  color: #6b7280;
}

/* RESPONSIVE */
@media (max-width: 480px) {
  .login-box {
    padding: 30px 20px;
  }
}

--------------------------------------------------------------------------------
FILE: static\css\style.css
--------------------------------------------------------------------------------
/* ============================
   PROSOLUTION DASHBOARD 3.0
   ============================ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  color: #111827;
  overflow-x: hidden;
}

/* LAYOUT */
.layout {
  display: flex;
  min-height: 100vh;
  flex-wrap: wrap;
}

/* SIDEBAR */
.sidebar {
  width: 260px;
  background: #0f172a;
  color: #fff;
  display: flex;
  flex-direction: column;
  padding: 20px;
  transition: all 0.3s ease;
}

.logo {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 30px;
}

.sidebar nav {
  flex: 1;
}

.sidebar nav a {
  display: block;
  padding: 10px 12px;
  color: #cbd5e1;
  text-decoration: none;
  border-radius: 8px;
  margin-bottom: 6px;
  font-size: 0.95rem;
  transition: 0.2s ease;
}

.sidebar nav a.active,
.sidebar nav a:hover {
  background: #1e293b;
  color: #fff;
}

.upgrade {
  background: #22c55e;
  border: none;
  padding: 10px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
  margin: 16px 0;
  transition: 0.2s ease;
}

.upgrade:hover {
  background: #16a34a;
}

.profile {
  display: flex;
  align-items: center;
  gap: 10px;
  border-top: 1px solid #1e293b;
  padding-top: 12px;
  margin-top: auto;
}

.avatar {
  background: #334155;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.profile strong {
  display: block;
  font-size: 0.9rem;
}

.profile span {
  color: #94a3b8;
  font-size: 0.75rem;
}

/* CONTENT */
.content {
  flex: 1;
  padding: 25px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* HEADER */
.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.topbar h1 {
  font-size: 1.3rem;
  font-weight: 600;
}

.new-post {
  background: #22c55e;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
}

.new-post:hover {
  background: #16a34a;
}

/* STATUS */
.status {
  padding: 14px;
  border-radius: 8px;
  background: #dcfce7;
  color: #166534;
  font-weight: 500;
  border: 1px solid #bbf7d0;
}

/* GRID */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 20px;
}

/* CARD */
.card {
  background: #fff;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.card h3 {
  font-size: 1.1rem;
  margin-bottom: 12px;
  color: #1e293b;
}

.fake-chart {
  background: #e5e7eb;
  height: 180px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #475569;
}

/* POSTS */
.post {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;
}

.post img {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
}

.post strong {
  display: block;
  font-size: 0.95rem;
}

.post span {
  color: #6b7280;
  font-size: 0.8rem;
}

.badge {
  margin-left: auto;
  background: #22c55e;
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.75rem;
}

/* BUTTONS */
.action {
  background: #2563eb;
  color: #fff;
  border: none;
  padding: 10px 14px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  transition: 0.2s ease;
}

.action:hover {
  background: #1d4ed8;
}

/* RESPONSIVE */
@media (max-width: 1024px) {
  .sidebar {
    width: 220px;
  }
}

@media (max-width: 768px) {
  .layout {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
  }

  .sidebar nav {
    display: flex;
    gap: 10px;
    overflow-x: auto;
  }

  .upgrade {
    display: none;
  }

  .profile {
    display: none;
  }

  .content {
    padding: 16px;
  }

  .topbar h1 {
    font-size: 1.1rem;
  }

  .card {
    padding: 16px;
  }
}

@media (max-width: 480px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .new-post {
    width: 100%;
  }

  .grid {
    grid-template-columns: 1fr;
  }
}

--------------------------------------------------------------------------------
FILE: static\js\matrix.js
--------------------------------------------------------------------------------
const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const chars = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%";
const fontSize = window.innerWidth < 600 ? 12 : 16;
let columns = Math.floor(canvas.width / fontSize);
let drops = Array(columns).fill(1);

function draw() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#00ff88";
  ctx.font = fontSize + "px monospace";

  for (let i = 0; i < drops.length; i++) {
    const text = chars[Math.floor(Math.random() * chars.length)];
    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }
    drops[i]++;
  }
}

setInterval(draw, 40);

--------------------------------------------------------------------------------
FILE: static\js\terminal.js
--------------------------------------------------------------------------------
// ==========================================
//  TERMINAL.JS | PROSOLUTION ‚öôÔ∏è IA SECURE MODE
//  Server-side client diagnostics + status
// ==========================================

async function updateServerInfo() {
  const text = document.getElementById("terminalBody");
  if (!text) return;

  text.innerHTML = "üß† Coletando informa√ß√µes do servidor...\nroot@prosolution:~$ _";

  let ip = "‚Äì";
  let country = "‚Äì";
  let region = "‚Äì";
  let org = "‚Äì";
  let vpn = "N√£o";
  let timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "‚Äì";
  let language = navigator.language || "‚Äì";
  let system = `${navigator.platform} / ${navigator.userAgent.split(")")[0].replace("(", "")}`;

  try {
    // üîπ API h√≠brida para IP + servidor
    const res = await fetch("https://ipapi.co/json/");
    const data = await res.json();

    if (data && data.ip) {
      ip = data.ip || "‚Äì";
      country = data.country_name || "‚Äì";
      region = data.region || "‚Äì";
      org = data.org || "‚Äì";

      // üîπ Heur√≠stica de VPN/Proxy
      const orgLower = org.toLowerCase();
      const vpnIndicators = [
        "vpn", "proxy", "datacenter", "cloudflare", "tor", "anonymous",
        "digitalocean", "aws", "ovh", "azure", "google", "contabo", "vultr"
      ];
      vpn = vpnIndicators.some(v => orgLower.includes(v)) ? "Sim" : "N√£o";
    } else {
      console.warn("‚ö†Ô∏è Falha ao decodificar resposta da API de IP.");
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Erro ao obter dados de rede:", err);
  }

  renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system);
}

// =======================
//   RENDERIZA√á√ÉO TERMINAL
// =======================
function renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system) {
  const now = new Date().toLocaleString();

  text.innerHTML = `
‚îå‚îÄ‚îÄ[ SERVER INFO ]
‚îÇ IP P√∫blico   : ${ip}
‚îÇ Servidor     : ${org}
‚îÇ Regi√£o       : ${region} - ${country}
‚îÇ Idioma       : ${language}
‚îÇ Fuso Hor√°rio : ${timezone}
‚îÇ Sistema      : ${system}
‚îÇ Data/Hora    : ${now}
‚îÇ VPN/Proxy    : ${vpn}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ[ SECURITY STATUS ]
‚îÇ ‚úî Firewall Ativo
‚îÇ ‚úî Criptografia AES-256
‚îÇ ‚úî Conex√£o HTTPS Segura
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

root@prosolution:~$ _
  `;
}

// =======================
//   BOT√ÉO POWER
// =======================
function togglePower() {
  const btn = document.getElementById("powerBtn");
  const terminal = document.querySelector(".terminal");
  const text = document.getElementById("terminalBody");

  if (!btn || !terminal || !text) return;

  btn.classList.toggle("on");

  if (btn.classList.contains("on")) {
    text.innerHTML = "‚ö° Inicializando sistema seguro...\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 50px #00ff88";
    setTimeout(updateServerInfo, 1200);
  } else {
    text.innerHTML = "üõë Sistema desligado.\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 15px #00ff88";
  }
}

// =======================
//   MODO AUTO / MANUAL
// =======================
let autoInterval = null;

function toggleMode() {
  const modeBtn = document.getElementById("modeBtn");
  if (!modeBtn) return;

  const isActive = modeBtn.classList.toggle("active");
  modeBtn.textContent = isActive ? "MANUAL" : "AUTO";

  if (!isActive) {
    // AUTO ON ‚Üí atualizar a cada 30s
    updateServerInfo();
    autoInterval = setInterval(updateServerInfo, 30000);
  } else {
    // MANUAL ‚Üí parar atualiza√ß√£o
    clearInterval(autoInterval);
  }
}

// =======================
//   HTTPS ENFORCER
// =======================
if (location.protocol !== "https:" && location.hostname !== "localhost") {
  location.href = "https://" + location.hostname + location.pathname;
}

// =======================
//   PREVINE DUPLICA√á√ÉO
// =======================
if (window.__terminalInitialized) {
  console.warn("‚ö†Ô∏è terminal.js j√° carregado ‚Äî ignorando duplicado.");
} else {
  window.__terminalInitialized = true;
  console.log("‚úÖ terminal.js Prosolution IA inicializado com seguran√ßa.");
}

// =======================
//   AUTOEXEC (SAFE MODE)
// =======================
document.addEventListener("DOMContentLoaded", () => {
  const powerBtn = document.getElementById("powerBtn");
  const modeBtn = document.getElementById("modeBtn");

  if (powerBtn) {
    powerBtn.addEventListener("click", togglePower);
  }

  if (modeBtn) {
    modeBtn.addEventListener("click", toggleMode);
  }

  // Auto start do terminal com boot animado
  const terminal = document.querySelector(".terminal");
  if (terminal) {
    terminal.style.opacity = "0";
    setTimeout(() => {
      terminal.style.transition = "opacity 1.2s ease";
      terminal.style.opacity = "1";
    }, 200);
  }
});

--------------------------------------------------------------------------------
FILE: templates\dashboard.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <title>Prosolution IA - Dashboard</title>
</head>
<body>
    <h1>üìä Dashboard Prosolution IA</h1>

    <ul id="metrics"></ul>

    <script>
        fetch("/dashboard/metrics")
            .then(res => res.json())
            .then(data => {
                const el = document.getElementById("metrics")
                el.innerHTML = `
                    <li>üì∏ Total de Posts: ${data.posts_total}</li>
                    <li>üí≥ Total de Pagamentos: ${data.payments_total}</li>
                    <li>üí∞ Faturamento Total: R$ ${data.revenue_total}</li>
                    <li>üïí √öltimo Post: ${data.last_post || "‚Äî"}</li>
                    <li>ü§ñ √öltima a√ß√£o da IA: ${data.last_ai_action || "‚Äî"}</li>
                `
            })
    </script>
</body>
</html>


--------------------------------------------------------------------------------
FILE: templates\login.html
--------------------------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prosolution | Secure Access</title>
<link rel="stylesheet" href="/static/css/login.css">
</head>
<body>

<div class="login-container">
  <div class="login-box">
    <div class="logo">
      üöÄ <span>Prosolution</span>
    </div>

    <h2>Welcome Back üëã</h2>
    <p>Sign in to access your AI Dashboard</p>

    <form method="post" action="/auth/login">
      <input type="email" name="email" placeholder="E-mail" required>
      <input type="password" name="password" placeholder="Password" required>
      <button type="submit">Login to Dashboard</button>
    </form>

    {% if error %}
      <span class="error">{{ error }}</span>
    {% endif %}
  </div>

  <footer>¬© 2025 Prosolution AI ‚Äî All rights reserved.</footer>
</div>

</body>
</html>

--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------
# üöÄ Prosolution API ‚Äî SaaS de Automa√ß√£o Inteligente

A **Prosolution API** √© uma plataforma **SaaS backend-first**, desenvolvida com **FastAPI**, focada em **seguran√ßa, automa√ß√£o e escalabilidade**, simulando um produto real pronto para mercado.

Este projeto foi pensado **al√©m do CRUD**, com vis√£o de arquitetura, autentica√ß√£o moderna, controle de usu√°rios, planos e deploy em produ√ß√£o.

---

## üß† Vis√£o do Projeto

O objetivo da Prosolution √© servir como **base s√≥lida para um SaaS profissional**, incluindo:

* Autentica√ß√£o real
* Seguran√ßa por IP
* Controle de usu√°rios e administradores
* Estrutura de monetiza√ß√£o
* C√≥digo limpo e organizado
* Deploy funcional em cloud (Render)

---

## üîê Funcionalidades Implementadas

### ‚úÖ Autentica√ß√£o & Seguran√ßa

* Login real com **PostgreSQL**
* Senhas criptografadas com **bcrypt**
* Autentica√ß√£o via **JWT**
* Sess√£o baseada em token
* Prote√ß√£o de rotas autenticadas
* Redirecionamento autom√°tico ap√≥s login

### üö´ Bloqueio de VPN / Proxy

* Valida√ß√£o de IP do cliente
* Bloqueio de acessos via VPN ou Proxy
* Estrutura pronta para integra√ß√£o com APIs anti-fraude

### üë• Usu√°rios & Admin

* Usu√°rios comuns
* Usu√°rios administradores
* Controle de permiss√µes
* Plano associado ao usu√°rio (free / pro / enterprise)

### üí≥ Monetiza√ß√£o (estrutura pronta)

* Base de planos no banco
* Controle de acesso por plano
* Preparado para Stripe / Mercado Pago

---

## üñ•Ô∏è Interface

* Tela de login moderna
* Dashboard autenticado
* UI estilo terminal / hacker
* Renderiza√ß√£o din√¢mica com dados do usu√°rio (JWT)

---

## üõ†Ô∏è Stack Tecnol√≥gica

* **Python 3.13**
* **FastAPI**
* **PostgreSQL**
* **JWT (python-jose)**
* **Passlib + Bcrypt**
* **Jinja2**
* **Uvicorn**
* **APScheduler**
* **HTML + CSS**
* **Deploy: Render**

---

## üìÇ Estrutura do Projeto

```
app/
‚îú‚îÄ‚îÄ auth/          # Autentica√ß√£o, JWT e seguran√ßa
‚îú‚îÄ‚îÄ dashboard/     # Rotas protegidas e dashboard
‚îú‚îÄ‚îÄ database/      # PostgreSQL e reposit√≥rios
‚îú‚îÄ‚îÄ scheduler/     # Automa√ß√£o e jobs
‚îú‚îÄ‚îÄ utils/         # VPN / Proxy block
‚îú‚îÄ‚îÄ main.py        # Entry point
static/
templates/
requirements.txt
README.md
```

---

## üöÄ Rodando Localmente

```bash
git clone https://github.com/Eduardo09e32y4rhf/Api-prosolution.git
cd Api-prosolution
python -m venv venv
venv\Scripts\activate   # Windows
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Acesse:

```
http://localhost:8000
```

---

## üåç Deploy

Aplica√ß√£o publicada na **Render**, com deploy autom√°tico via GitHub.

---

## üë®‚Äçüíª Sobre o Desenvolvedor

**Jos√© Eduardo da Silva**
üéì Formado em **An√°lise e Desenvolvimento de Sistemas**
üíª Backend Developer ‚Äî APIs, Automa√ß√£o e Seguran√ßa

Experi√™ncia pr√°tica com:

* FastAPI
* Arquitetura backend
* Autentica√ß√£o JWT
* Banco de dados
* Deploy em produ√ß√£o

Este projeto demonstra **capacidade t√©cnica + vis√£o de produto**, indo al√©m de exemplos b√°sicos.

üîó GitHub: [https://github.com/Eduardo09e32y4rhf](https://github.com/Eduardo09e32y4rhf)

---

## ‚≠ê Conclus√£o

A **Prosolution API** √© uma base real para um SaaS moderno, pronta para evolu√ß√£o com:

* Pagamentos reais
* Multi-tenant
* Logs e m√©tricas
* Escala horizontal
* Painel administrativo completo

> C√≥digo limpo, funcional e com vis√£o de mercado.


--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
fastapi==0.124.4
uvicorn==0.38.0

SQLAlchemy==2.0.36
greenlet>=3.0.0
asyncpg
aiosqlite
psycopg[binary]>=3.1


python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

python-dotenv==1.2.1
python-multipart==0.0.20

Jinja2==3.1.6
requests==2.32.5
pytz==2025.2
httpx==0.27.0
pydantic-settings
email-validator

--------------------------------------------------------------------------------
FILE: static\css\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: static\css\login.css
--------------------------------------------------------------------------------
/* =======================
   PROSOLUTION LOGIN 2.0
   ======================= */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  flex-direction: column;
  color: #111827;
}

/* CONTAINER */
.login-container {
  width: 100%;
  max-width: 420px;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

/* BOX */
.login-box {
  background: #ffffff;
  border-radius: 16px;
  padding: 40px 36px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
  width: 100%;
  text-align: center;
}

.logo {
  font-weight: 700;
  font-size: 1.5rem;
  color: #0f172a;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}

.logo span {
  color: #22c55e;
}

/* TITLES */
.login-box h2 {
  font-size: 1.25rem;
  margin-bottom: 6px;
}

.login-box p {
  color: #6b7280;
  font-size: 0.9rem;
  margin-bottom: 28px;
}

/* FORM */
form {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

input {
  padding: 14px 16px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
  font-size: 0.95rem;
  color: #111827;
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2);
}

/* BUTTON */
button {
  padding: 14px;
  border-radius: 10px;
  background: #22c55e;
  border: none;
  color: white;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

button:hover {
  background: #16a34a;
  box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
}

/* ERROR MESSAGE */
.error {
  margin-top: 14px;
  color: #dc2626;
  background: #fee2e2;
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 0.85rem;
  display: inline-block;
}

/* FOOTER */
footer {
  margin-top: 30px;
  font-size: 0.8rem;
  color: #6b7280;
}

/* RESPONSIVE */
@media (max-width: 480px) {
  .login-box {
    padding: 30px 20px;
  }
}

--------------------------------------------------------------------------------
FILE: static\css\style.css
--------------------------------------------------------------------------------
/* ============================
   PROSOLUTION DASHBOARD 3.0
   ============================ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  color: #111827;
  overflow-x: hidden;
}

/* LAYOUT */
.layout {
  display: flex;
  min-height: 100vh;
  flex-wrap: wrap;
}

/* SIDEBAR */
.sidebar {
  width: 260px;
  background: #0f172a;
  color: #fff;
  display: flex;
  flex-direction: column;
  padding: 20px;
  transition: all 0.3s ease;
}

.logo {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 30px;
}

.sidebar nav {
  flex: 1;
}

.sidebar nav a {
  display: block;
  padding: 10px 12px;
  color: #cbd5e1;
  text-decoration: none;
  border-radius: 8px;
  margin-bottom: 6px;
  font-size: 0.95rem;
  transition: 0.2s ease;
}

.sidebar nav a.active,
.sidebar nav a:hover {
  background: #1e293b;
  color: #fff;
}

.upgrade {
  background: #22c55e;
  border: none;
  padding: 10px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
  margin: 16px 0;
  transition: 0.2s ease;
}

.upgrade:hover {
  background: #16a34a;
}

.profile {
  display: flex;
  align-items: center;
  gap: 10px;
  border-top: 1px solid #1e293b;
  padding-top: 12px;
  margin-top: auto;
}

.avatar {
  background: #334155;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.profile strong {
  display: block;
  font-size: 0.9rem;
}

.profile span {
  color: #94a3b8;
  font-size: 0.75rem;
}

/* CONTENT */
.content {
  flex: 1;
  padding: 25px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* HEADER */
.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.topbar h1 {
  font-size: 1.3rem;
  font-weight: 600;
}

.new-post {
  background: #22c55e;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
}

.new-post:hover {
  background: #16a34a;
}

/* STATUS */
.status {
  padding: 14px;
  border-radius: 8px;
  background: #dcfce7;
  color: #166534;
  font-weight: 500;
  border: 1px solid #bbf7d0;
}

/* GRID */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 20px;
}

/* CARD */
.card {
  background: #fff;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.card h3 {
  font-size: 1.1rem;
  margin-bottom: 12px;
  color: #1e293b;
}

.fake-chart {
  background: #e5e7eb;
  height: 180px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #475569;
}

/* POSTS */
.post {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;
}

.post img {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
}

.post strong {
  display: block;
  font-size: 0.95rem;
}

.post span {
  color: #6b7280;
  font-size: 0.8rem;
}

.badge {
  margin-left: auto;
  background: #22c55e;
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.75rem;
}

/* BUTTONS */
.action {
  background: #2563eb;
  color: #fff;
  border: none;
  padding: 10px 14px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  transition: 0.2s ease;
}

.action:hover {
  background: #1d4ed8;
}

/* RESPONSIVE */
@media (max-width: 1024px) {
  .sidebar {
    width: 220px;
  }
}

@media (max-width: 768px) {
  .layout {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
  }

  .sidebar nav {
    display: flex;
    gap: 10px;
    overflow-x: auto;
  }

  .upgrade {
    display: none;
  }

  .profile {
    display: none;
  }

  .content {
    padding: 16px;
  }

  .topbar h1 {
    font-size: 1.1rem;
  }

  .card {
    padding: 16px;
  }
}

@media (max-width: 480px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .new-post {
    width: 100%;
  }

  .grid {
    grid-template-columns: 1fr;
  }
}

--------------------------------------------------------------------------------
FILE: static\js\matrix.js
--------------------------------------------------------------------------------
const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const chars = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%";
const fontSize = window.innerWidth < 600 ? 12 : 16;
let columns = Math.floor(canvas.width / fontSize);
let drops = Array(columns).fill(1);

function draw() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#00ff88";
  ctx.font = fontSize + "px monospace";

  for (let i = 0; i < drops.length; i++) {
    const text = chars[Math.floor(Math.random() * chars.length)];
    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }
    drops[i]++;
  }
}

setInterval(draw, 40);

--------------------------------------------------------------------------------
FILE: static\js\terminal.js
--------------------------------------------------------------------------------
// ==========================================
//  TERMINAL.JS | PROSOLUTION ‚öôÔ∏è IA SECURE MODE
//  Server-side client diagnostics + status
// ==========================================

async function updateServerInfo() {
  const text = document.getElementById("terminalBody");
  if (!text) return;

  text.innerHTML = "üß† Coletando informa√ß√µes do servidor...\nroot@prosolution:~$ _";

  let ip = "‚Äì";
  let country = "‚Äì";
  let region = "‚Äì";
  let org = "‚Äì";
  let vpn = "N√£o";
  let timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "‚Äì";
  let language = navigator.language || "‚Äì";
  let system = `${navigator.platform} / ${navigator.userAgent.split(")")[0].replace("(", "")}`;

  try {
    // üîπ API h√≠brida para IP + servidor
    const res = await fetch("https://ipapi.co/json/");
    const data = await res.json();

    if (data && data.ip) {
      ip = data.ip || "‚Äì";
      country = data.country_name || "‚Äì";
      region = data.region || "‚Äì";
      org = data.org || "‚Äì";

      // üîπ Heur√≠stica de VPN/Proxy
      const orgLower = org.toLowerCase();
      const vpnIndicators = [
        "vpn", "proxy", "datacenter", "cloudflare", "tor", "anonymous",
        "digitalocean", "aws", "ovh", "azure", "google", "contabo", "vultr"
      ];
      vpn = vpnIndicators.some(v => orgLower.includes(v)) ? "Sim" : "N√£o";
    } else {
      console.warn("‚ö†Ô∏è Falha ao decodificar resposta da API de IP.");
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Erro ao obter dados de rede:", err);
  }

  renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system);
}

// =======================
//   RENDERIZA√á√ÉO TERMINAL
// =======================
function renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system) {
  const now = new Date().toLocaleString();

  text.innerHTML = `
‚îå‚îÄ‚îÄ[ SERVER INFO ]
‚îÇ IP P√∫blico   : ${ip}
‚îÇ Servidor     : ${org}
‚îÇ Regi√£o       : ${region} - ${country}
‚îÇ Idioma       : ${language}
‚îÇ Fuso Hor√°rio : ${timezone}
‚îÇ Sistema      : ${system}
‚îÇ Data/Hora    : ${now}
‚îÇ VPN/Proxy    : ${vpn}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ[ SECURITY STATUS ]
‚îÇ ‚úî Firewall Ativo
‚îÇ ‚úî Criptografia AES-256
‚îÇ ‚úî Conex√£o HTTPS Segura
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

root@prosolution:~$ _
  `;
}

// =======================
//   BOT√ÉO POWER
// =======================
function togglePower() {
  const btn = document.getElementById("powerBtn");
  const terminal = document.querySelector(".terminal");
  const text = document.getElementById("terminalBody");

  if (!btn || !terminal || !text) return;

  btn.classList.toggle("on");

  if (btn.classList.contains("on")) {
    text.innerHTML = "‚ö° Inicializando sistema seguro...\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 50px #00ff88";
    setTimeout(updateServerInfo, 1200);
  } else {
    text.innerHTML = "üõë Sistema desligado.\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 15px #00ff88";
  }
}

// =======================
//   MODO AUTO / MANUAL
// =======================
let autoInterval = null;

function toggleMode() {
  const modeBtn = document.getElementById("modeBtn");
  if (!modeBtn) return;

  const isActive = modeBtn.classList.toggle("active");
  modeBtn.textContent = isActive ? "MANUAL" : "AUTO";

  if (!isActive) {
    // AUTO ON ‚Üí atualizar a cada 30s
    updateServerInfo();
    autoInterval = setInterval(updateServerInfo, 30000);
  } else {
    // MANUAL ‚Üí parar atualiza√ß√£o
    clearInterval(autoInterval);
  }
}

// =======================
//   HTTPS ENFORCER
// =======================
if (location.protocol !== "https:" && location.hostname !== "localhost") {
  location.href = "https://" + location.hostname + location.pathname;
}

// =======================
//   PREVINE DUPLICA√á√ÉO
// =======================
if (window.__terminalInitialized) {
  console.warn("‚ö†Ô∏è terminal.js j√° carregado ‚Äî ignorando duplicado.");
} else {
  window.__terminalInitialized = true;
  console.log("‚úÖ terminal.js Prosolution IA inicializado com seguran√ßa.");
}

// =======================
//   AUTOEXEC (SAFE MODE)
// =======================
document.addEventListener("DOMContentLoaded", () => {
  const powerBtn = document.getElementById("powerBtn");
  const modeBtn = document.getElementById("modeBtn");

  if (powerBtn) {
    powerBtn.addEventListener("click", togglePower);
  }

  if (modeBtn) {
    modeBtn.addEventListener("click", toggleMode);
  }

  // Auto start do terminal com boot animado
  const terminal = document.querySelector(".terminal");
  if (terminal) {
    terminal.style.opacity = "0";
    setTimeout(() => {
      terminal.style.transition = "opacity 1.2s ease";
      terminal.style.opacity = "1";
    }, 200);
  }
});

--------------------------------------------------------------------------------
FILE: templates\dashboard.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <title>Prosolution IA - Dashboard</title>
</head>
<body>
    <h1>üìä Dashboard Prosolution IA</h1>

    <ul id="metrics"></ul>

    <script>
        fetch("/dashboard/metrics")
            .then(res => res.json())
            .then(data => {
                const el = document.getElementById("metrics")
                el.innerHTML = `
                    <li>üì∏ Total de Posts: ${data.posts_total}</li>
                    <li>üí≥ Total de Pagamentos: ${data.payments_total}</li>
                    <li>üí∞ Faturamento Total: R$ ${data.revenue_total}</li>
                    <li>üïí √öltimo Post: ${data.last_post || "‚Äî"}</li>
                    <li>ü§ñ √öltima a√ß√£o da IA: ${data.last_ai_action || "‚Äî"}</li>
                `
            })
    </script>
</body>
</html>


--------------------------------------------------------------------------------
FILE: templates\login.html
--------------------------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prosolution | Secure Access</title>
<link rel="stylesheet" href="/static/css/login.css">
</head>
<body>

<div class="login-container">
  <div class="login-box">
    <div class="logo">
      üöÄ <span>Prosolution</span>
    </div>

    <h2>Welcome Back üëã</h2>
    <p>Sign in to access your AI Dashboard</p>

    <form method="post" action="/auth/login">
      <input type="email" name="email" placeholder="E-mail" required>
      <input type="password" name="password" placeholder="Password" required>
      <button type="submit">Login to Dashboard</button>
    </form>

    {% if error %}
      <span class="error">{{ error }}</span>
    {% endif %}
  </div>

  <footer>¬© 2025 Prosolution AI ‚Äî All rights reserved.</footer>
</div>

</body>
</html>

--------------------------------------------------------------------------------
FILE: README.md
--------------------------------------------------------------------------------
# üöÄ Prosolution API ‚Äî SaaS de Automa√ß√£o Inteligente

A **Prosolution API** √© uma plataforma **SaaS backend-first**, desenvolvida com **FastAPI**, focada em **seguran√ßa, automa√ß√£o e escalabilidade**, simulando um produto real pronto para mercado.

Este projeto foi pensado **al√©m do CRUD**, com vis√£o de arquitetura, autentica√ß√£o moderna, controle de usu√°rios, planos e deploy em produ√ß√£o.

---

## üß† Vis√£o do Projeto

O objetivo da Prosolution √© servir como **base s√≥lida para um SaaS profissional**, incluindo:

* Autentica√ß√£o real
* Seguran√ßa por IP
* Controle de usu√°rios e administradores
* Estrutura de monetiza√ß√£o
* C√≥digo limpo e organizado
* Deploy funcional em cloud (Render)

---

## üîê Funcionalidades Implementadas

### ‚úÖ Autentica√ß√£o & Seguran√ßa

* Login real com **PostgreSQL**
* Senhas criptografadas com **bcrypt**
* Autentica√ß√£o via **JWT**
* Sess√£o baseada em token
* Prote√ß√£o de rotas autenticadas
* Redirecionamento autom√°tico ap√≥s login

### üö´ Bloqueio de VPN / Proxy

* Valida√ß√£o de IP do cliente
* Bloqueio de acessos via VPN ou Proxy
* Estrutura pronta para integra√ß√£o com APIs anti-fraude

### üë• Usu√°rios & Admin

* Usu√°rios comuns
* Usu√°rios administradores
* Controle de permiss√µes
* Plano associado ao usu√°rio (free / pro / enterprise)

### üí≥ Monetiza√ß√£o (estrutura pronta)

* Base de planos no banco
* Controle de acesso por plano
* Preparado para Stripe / Mercado Pago

---

## üñ•Ô∏è Interface

* Tela de login moderna
* Dashboard autenticado
* UI estilo terminal / hacker
* Renderiza√ß√£o din√¢mica com dados do usu√°rio (JWT)

---

## üõ†Ô∏è Stack Tecnol√≥gica

* **Python 3.13**
* **FastAPI**
* **PostgreSQL**
* **JWT (python-jose)**
* **Passlib + Bcrypt**
* **Jinja2**
* **Uvicorn**
* **APScheduler**
* **HTML + CSS**
* **Deploy: Render**

---

## üìÇ Estrutura do Projeto

```
app/
‚îú‚îÄ‚îÄ auth/          # Autentica√ß√£o, JWT e seguran√ßa
‚îú‚îÄ‚îÄ dashboard/     # Rotas protegidas e dashboard
‚îú‚îÄ‚îÄ database/      # PostgreSQL e reposit√≥rios
‚îú‚îÄ‚îÄ scheduler/     # Automa√ß√£o e jobs
‚îú‚îÄ‚îÄ utils/         # VPN / Proxy block
‚îú‚îÄ‚îÄ main.py        # Entry point
static/
templates/
requirements.txt
README.md
```

---

## üöÄ Rodando Localmente

```bash
git clone https://github.com/Eduardo09e32y4rhf/Api-prosolution.git
cd Api-prosolution
python -m venv venv
venv\Scripts\activate   # Windows
pip install -r requirements.txt
uvicorn app.main:app --reload
```

Acesse:

```
http://localhost:8000
```

---

## üåç Deploy

Aplica√ß√£o publicada na **Render**, com deploy autom√°tico via GitHub.

---

## üë®‚Äçüíª Sobre o Desenvolvedor

**Jos√© Eduardo da Silva**
üéì Formado em **An√°lise e Desenvolvimento de Sistemas**
üíª Backend Developer ‚Äî APIs, Automa√ß√£o e Seguran√ßa

Experi√™ncia pr√°tica com:

* FastAPI
* Arquitetura backend
* Autentica√ß√£o JWT
* Banco de dados
* Deploy em produ√ß√£o

Este projeto demonstra **capacidade t√©cnica + vis√£o de produto**, indo al√©m de exemplos b√°sicos.

üîó GitHub: [https://github.com/Eduardo09e32y4rhf](https://github.com/Eduardo09e32y4rhf)

---

## ‚≠ê Conclus√£o

A **Prosolution API** √© uma base real para um SaaS moderno, pronta para evolu√ß√£o com:

* Pagamentos reais
* Multi-tenant
* Logs e m√©tricas
* Escala horizontal
* Painel administrativo completo

> C√≥digo limpo, funcional e com vis√£o de mercado.


--------------------------------------------------------------------------------
FILE: requirements.txt
--------------------------------------------------------------------------------
fastapi==0.124.4
uvicorn==0.38.0

SQLAlchemy==2.0.36
greenlet>=3.0.0
asyncpg
aiosqlite
psycopg[binary]>=3.1


python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4

python-dotenv==1.2.1
python-multipart==0.0.20

Jinja2==3.1.6
requests==2.32.5
pytz==2025.2
httpx==0.27.0
pydantic-settings
email-validator

--------------------------------------------------------------------------------
FILE: static\css\__init__.py
--------------------------------------------------------------------------------


--------------------------------------------------------------------------------
FILE: static\css\login.css
--------------------------------------------------------------------------------
/* =======================
   PROSOLUTION LOGIN 2.0
   ======================= */

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  flex-direction: column;
  color: #111827;
}

/* CONTAINER */
.login-container {
  width: 100%;
  max-width: 420px;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
}

/* BOX */
.login-box {
  background: #ffffff;
  border-radius: 16px;
  padding: 40px 36px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
  width: 100%;
  text-align: center;
}

.logo {
  font-weight: 700;
  font-size: 1.5rem;
  color: #0f172a;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  margin-bottom: 20px;
}

.logo span {
  color: #22c55e;
}

/* TITLES */
.login-box h2 {
  font-size: 1.25rem;
  margin-bottom: 6px;
}

.login-box p {
  color: #6b7280;
  font-size: 0.9rem;
  margin-bottom: 28px;
}

/* FORM */
form {
  display: flex;
  flex-direction: column;
  gap: 14px;
}

input {
  padding: 14px 16px;
  border-radius: 10px;
  border: 1px solid #d1d5db;
  background: #f9fafb;
  font-size: 0.95rem;
  color: #111827;
  transition: all 0.2s ease;
}

input:focus {
  outline: none;
  border-color: #22c55e;
  box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.2);
}

/* BUTTON */
button {
  padding: 14px;
  border-radius: 10px;
  background: #22c55e;
  border: none;
  color: white;
  font-weight: 600;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

button:hover {
  background: #16a34a;
  box-shadow: 0 4px 10px rgba(34, 197, 94, 0.3);
}

/* ERROR MESSAGE */
.error {
  margin-top: 14px;
  color: #dc2626;
  background: #fee2e2;
  border-radius: 8px;
  padding: 8px 10px;
  font-size: 0.85rem;
  display: inline-block;
}

/* FOOTER */
footer {
  margin-top: 30px;
  font-size: 0.8rem;
  color: #6b7280;
}

/* RESPONSIVE */
@media (max-width: 480px) {
  .login-box {
    padding: 30px 20px;
  }
}

--------------------------------------------------------------------------------
FILE: static\css\style.css
--------------------------------------------------------------------------------
/* ============================
   PROSOLUTION DASHBOARD 3.0
   ============================ */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Inter", sans-serif;
}

body {
  background: #f4f6f8;
  color: #111827;
  overflow-x: hidden;
}

/* LAYOUT */
.layout {
  display: flex;
  min-height: 100vh;
  flex-wrap: wrap;
}

/* SIDEBAR */
.sidebar {
  width: 260px;
  background: #0f172a;
  color: #fff;
  display: flex;
  flex-direction: column;
  padding: 20px;
  transition: all 0.3s ease;
}

.logo {
  font-size: 1.5rem;
  font-weight: bold;
  margin-bottom: 30px;
}

.sidebar nav {
  flex: 1;
}

.sidebar nav a {
  display: block;
  padding: 10px 12px;
  color: #cbd5e1;
  text-decoration: none;
  border-radius: 8px;
  margin-bottom: 6px;
  font-size: 0.95rem;
  transition: 0.2s ease;
}

.sidebar nav a.active,
.sidebar nav a:hover {
  background: #1e293b;
  color: #fff;
}

.upgrade {
  background: #22c55e;
  border: none;
  padding: 10px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
  margin: 16px 0;
  transition: 0.2s ease;
}

.upgrade:hover {
  background: #16a34a;
}

.profile {
  display: flex;
  align-items: center;
  gap: 10px;
  border-top: 1px solid #1e293b;
  padding-top: 12px;
  margin-top: auto;
}

.avatar {
  background: #334155;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.profile strong {
  display: block;
  font-size: 0.9rem;
}

.profile span {
  color: #94a3b8;
  font-size: 0.75rem;
}

/* CONTENT */
.content {
  flex: 1;
  padding: 25px;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

/* HEADER */
.topbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 10px;
}

.topbar h1 {
  font-size: 1.3rem;
  font-weight: 600;
}

.new-post {
  background: #22c55e;
  border: none;
  padding: 10px 16px;
  border-radius: 8px;
  color: #fff;
  cursor: pointer;
  font-weight: 600;
}

.new-post:hover {
  background: #16a34a;
}

/* STATUS */
.status {
  padding: 14px;
  border-radius: 8px;
  background: #dcfce7;
  color: #166534;
  font-weight: 500;
  border: 1px solid #bbf7d0;
}

/* GRID */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
  gap: 20px;
}

/* CARD */
.card {
  background: #fff;
  border-radius: 12px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
  transition: all 0.2s ease;
}

.card:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
}

.card h3 {
  font-size: 1.1rem;
  margin-bottom: 12px;
  color: #1e293b;
}

.fake-chart {
  background: #e5e7eb;
  height: 180px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #475569;
}

/* POSTS */
.post {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 14px;
}

.post img {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  object-fit: cover;
}

.post strong {
  display: block;
  font-size: 0.95rem;
}

.post span {
  color: #6b7280;
  font-size: 0.8rem;
}

.badge {
  margin-left: auto;
  background: #22c55e;
  color: #fff;
  padding: 4px 8px;
  border-radius: 6px;
  font-size: 0.75rem;
}

/* BUTTONS */
.action {
  background: #2563eb;
  color: #fff;
  border: none;
  padding: 10px 14px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 500;
  transition: 0.2s ease;
}

.action:hover {
  background: #1d4ed8;
}

/* RESPONSIVE */
@media (max-width: 1024px) {
  .sidebar {
    width: 220px;
  }
}

@media (max-width: 768px) {
  .layout {
    flex-direction: column;
  }

  .sidebar {
    width: 100%;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
  }

  .sidebar nav {
    display: flex;
    gap: 10px;
    overflow-x: auto;
  }

  .upgrade {
    display: none;
  }

  .profile {
    display: none;
  }

  .content {
    padding: 16px;
  }

  .topbar h1 {
    font-size: 1.1rem;
  }

  .card {
    padding: 16px;
  }
}

@media (max-width: 480px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
  }

  .new-post {
    width: 100%;
  }

  .grid {
    grid-template-columns: 1fr;
  }
}

--------------------------------------------------------------------------------
FILE: static\js\matrix.js
--------------------------------------------------------------------------------
const canvas = document.getElementById("matrix");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

const chars = "01ABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%";
const fontSize = window.innerWidth < 600 ? 12 : 16;
let columns = Math.floor(canvas.width / fontSize);
let drops = Array(columns).fill(1);

function draw() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.08)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "#00ff88";
  ctx.font = fontSize + "px monospace";

  for (let i = 0; i < drops.length; i++) {
    const text = chars[Math.floor(Math.random() * chars.length)];
    ctx.fillText(text, i * fontSize, drops[i] * fontSize);

    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }
    drops[i]++;
  }
}

setInterval(draw, 40);

--------------------------------------------------------------------------------
FILE: static\js\terminal.js
--------------------------------------------------------------------------------
// ==========================================
//  TERMINAL.JS | PROSOLUTION ‚öôÔ∏è IA SECURE MODE
//  Server-side client diagnostics + status
// ==========================================

async function updateServerInfo() {
  const text = document.getElementById("terminalBody");
  if (!text) return;

  text.innerHTML = "üß† Coletando informa√ß√µes do servidor...\nroot@prosolution:~$ _";

  let ip = "‚Äì";
  let country = "‚Äì";
  let region = "‚Äì";
  let org = "‚Äì";
  let vpn = "N√£o";
  let timezone = Intl.DateTimeFormat().resolvedOptions().timeZone || "‚Äì";
  let language = navigator.language || "‚Äì";
  let system = `${navigator.platform} / ${navigator.userAgent.split(")")[0].replace("(", "")}`;

  try {
    // üîπ API h√≠brida para IP + servidor
    const res = await fetch("https://ipapi.co/json/");
    const data = await res.json();

    if (data && data.ip) {
      ip = data.ip || "‚Äì";
      country = data.country_name || "‚Äì";
      region = data.region || "‚Äì";
      org = data.org || "‚Äì";

      // üîπ Heur√≠stica de VPN/Proxy
      const orgLower = org.toLowerCase();
      const vpnIndicators = [
        "vpn", "proxy", "datacenter", "cloudflare", "tor", "anonymous",
        "digitalocean", "aws", "ovh", "azure", "google", "contabo", "vultr"
      ];
      vpn = vpnIndicators.some(v => orgLower.includes(v)) ? "Sim" : "N√£o";
    } else {
      console.warn("‚ö†Ô∏è Falha ao decodificar resposta da API de IP.");
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Erro ao obter dados de rede:", err);
  }

  renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system);
}

// =======================
//   RENDERIZA√á√ÉO TERMINAL
// =======================
function renderServerInfo(text, ip, org, region, country, vpn, timezone, language, system) {
  const now = new Date().toLocaleString();

  text.innerHTML = `
‚îå‚îÄ‚îÄ[ SERVER INFO ]
‚îÇ IP P√∫blico   : ${ip}
‚îÇ Servidor     : ${org}
‚îÇ Regi√£o       : ${region} - ${country}
‚îÇ Idioma       : ${language}
‚îÇ Fuso Hor√°rio : ${timezone}
‚îÇ Sistema      : ${system}
‚îÇ Data/Hora    : ${now}
‚îÇ VPN/Proxy    : ${vpn}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚îå‚îÄ‚îÄ[ SECURITY STATUS ]
‚îÇ ‚úî Firewall Ativo
‚îÇ ‚úî Criptografia AES-256
‚îÇ ‚úî Conex√£o HTTPS Segura
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

root@prosolution:~$ _
  `;
}

// =======================
//   BOT√ÉO POWER
// =======================
function togglePower() {
  const btn = document.getElementById("powerBtn");
  const terminal = document.querySelector(".terminal");
  const text = document.getElementById("terminalBody");

  if (!btn || !terminal || !text) return;

  btn.classList.toggle("on");

  if (btn.classList.contains("on")) {
    text.innerHTML = "‚ö° Inicializando sistema seguro...\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 50px #00ff88";
    setTimeout(updateServerInfo, 1200);
  } else {
    text.innerHTML = "üõë Sistema desligado.\nroot@prosolution:~$ _";
    terminal.style.boxShadow = "0 0 15px #00ff88";
  }
}

// =======================
//   MODO AUTO / MANUAL
// =======================
let autoInterval = null;

function toggleMode() {
  const modeBtn = document.getElementById("modeBtn");
  if (!modeBtn) return;

  const isActive = modeBtn.classList.toggle("active");
  modeBtn.textContent = isActive ? "MANUAL" : "AUTO";

  if (!isActive) {
    // AUTO ON ‚Üí atualizar a cada 30s
    updateServerInfo();
    autoInterval = setInterval(updateServerInfo, 30000);
  } else {
    // MANUAL ‚Üí parar atualiza√ß√£o
    clearInterval(autoInterval);
  }
}

// =======================
//   HTTPS ENFORCER
// =======================
if (location.protocol !== "https:" && location.hostname !== "localhost") {
  location.href = "https://" + location.hostname + location.pathname;
}

// =======================
//   PREVINE DUPLICA√á√ÉO
// =======================
if (window.__terminalInitialized) {
  console.warn("‚ö†Ô∏è terminal.js j√° carregado ‚Äî ignorando duplicado.");
} else {
  window.__terminalInitialized = true;
  console.log("‚úÖ terminal.js Prosolution IA inicializado com seguran√ßa.");
}

// =======================
//   AUTOEXEC (SAFE MODE)
// =======================
document.addEventListener("DOMContentLoaded", () => {
  const powerBtn = document.getElementById("powerBtn");
  const modeBtn = document.getElementById("modeBtn");

  if (powerBtn) {
    powerBtn.addEventListener("click", togglePower);
  }

  if (modeBtn) {
    modeBtn.addEventListener("click", toggleMode);
  }

  // Auto start do terminal com boot animado
  const terminal = document.querySelector(".terminal");
  if (terminal) {
    terminal.style.opacity = "0";
    setTimeout(() => {
      terminal.style.transition = "opacity 1.2s ease";
      terminal.style.opacity = "1";
    }, 200);
  }
});

--------------------------------------------------------------------------------
FILE: templates\dashboard.html
--------------------------------------------------------------------------------
<!DOCTYPE html>
<html>
<head>
    <title>Prosolution IA - Dashboard</title>
</head>
<body>
    <h1>üìä Dashboard Prosolution IA</h1>

    <ul id="metrics"></ul>

    <script>
        fetch("/dashboard/metrics")
            .then(res => res.json())
            .then(data => {
                const el = document.getElementById("metrics")
                el.innerHTML = `
                    <li>üì∏ Total de Posts: ${data.posts_total}</li>
                    <li>üí≥ Total de Pagamentos: ${data.payments_total}</li>
                    <li>üí∞ Faturamento Total: R$ ${data.revenue_total}</li>
                    <li>üïí √öltimo Post: ${data.last_post || "‚Äî"}</li>
                    <li>ü§ñ √öltima a√ß√£o da IA: ${data.last_ai_action || "‚Äî"}</li>
                `
            })
    </script>
</body>
</html>


--------------------------------------------------------------------------------
FILE: templates\login.html
--------------------------------------------------------------------------------

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prosolution | Secure Access</title>
<link rel="stylesheet" href="/static/css/login.css">
</head>
<body>

<div class="login-container">
  <div class="login-box">
    <div class="logo">
      üöÄ <span>Prosolution</span>
    </div>

    <h2>Welcome Back üëã</h2>
    <p>Sign in to access your AI Dashboard</p>

    <form method="post" action="/auth/login">
      <input type="email" name="email" placeholder="E-mail" required>
      <input type="password" name="password" placeholder="Password" required>
      <button type="submit">Login to Dashboard</button>
    </form>

    {% if error %}
      <span class="error">{{ error }}</span>
    {% endif %}
  </div>

  <footer>¬© 2025 Prosolution AI ‚Äî All rights reserved.</footer>
</div>

</body>
</html>